<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js高级程序设计]]></title>
    <url>%2F2018%2F06%2F02%2Fjs-high-design%2F</url>
    <content type="text"><![CDATA[此文是对js高级程序设计一书难点的总结，预计1-2周内可以完成，本有相当经典，希望能有所收获 1. Number类型关键点讲解 1.进制问题 1231.八进制字面量在严格模式下无效，会导致支持该模式的js引擎抛出异常2.十六进制字面量的前两位必须是0x，后根任何十六进制数字（0-9及A-F）3.在进行算术计算时，所有以八进制和十六进制表示的数值最终将被转换成十进制数值 2.浮点数注意点 1231.浮点数值的最高精度是17位小数，但在进行算术计算时精度远远不如整数。例如0.1 + 0.2 === 0.300000000000004(大致这个意思，具体多少个零请实际计算)所以永远不要测试某个特定的浮点数值 3.数值 12341.使用isFinite(num)来确定一个数字是否有穷2.ECMAScript能够表示的最小值保存在变量 Number.MIN_VALUE 中，最大值保存在 Number.MAX_VALUE 中。3.NaN表示非数值。在ECMAScript中，任何数值除以非数值会返回NaN,因此不会影响其他代码的执行。4.isNaN()用来确定传入的参数是否为"非数值"。会对参数进行转化，不能被转化为数值的则返回true。 4.数值转换 1parseFloat主要用于解析有效的浮点数字，始终会忽略前导的零，可识别所有的浮点数格式，但是十六进制格式的字符串始终会被转换成零。 2. 字符串 toString() 转换为字符串 12let num = 10;num.toString(n) n表示进制，可选，如2，8，10，16 3.循环 break和continue 12345678910111213break语句会立即退出循环，强制执行循环后面的语句continue语句是退出当前循环，继续执行下一循环// 结合label,更精确的控制循环outerMost:for(var i=0;i&lt;10;i++)&#123; for(var j=0;i&lt;10;j++)&#123; if(i = 5)&#123; break outerMost &#125; &#125;&#125;此时直接退出外部循环，continue也是类似 switch语句在比较值时使用的是全等操作符，所以不会发生类型转换 函数参数arguments和命名参数 1234// 此时读取n2和arguments[1]并不会访问相同的内存空间，他们的内存空间是独立的，但他们的值保持同步function add(n1, n2)&#123; arguments[1] = 10;&#125; 4.变量，作用域和内存问题 1.传递参数 1231.所有的参数都是按值传递的。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反应在函数外部2.当在函数内部重写obj时，这个变量引用的就是一个局部对象。而这个局部对象会在函数执行完毕后立即被销毁。 2.垃圾收集 121.js最常用的垃圾收集机制为“标记清除”，另一种不常用的是“引用计数”。2.原理：找出不再继续使用的变量，然后释放其内存空间。垃圾收集器会在固定的时间间隔周期性的执行这一操作。 3.管理内存 11.解除引用：数据不再有用，将其值设置为null 5.引用类型 1.数组 12345678910111213141516// 检测数值ES5方法Array.isArray(value) // 检测值是否为数组// 转换方法toString() 将数组转化为以逗号分隔的字符串valueOf() 返回的还是数组// 栈方法push() 可以接收任意数量的参数，把他们逐个添加到数组的末尾，返回修改后数组的长度pop() 从数组末尾移除最后一项，返回移除的项// 队列方法shift() 移除数组的第一项并返回该项unshift() 向数组前端添加任意个项并返回新数组的长度// 排序sort(compare)compare函数接收两个参数,如果返回负数，则第一个参数位于第二个参数前面；如果返回零，则两个参数相等；如果返回正数，第一个参数位于第二个参数后面// 降序，升序相反(a,b) =&gt; (b-a)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>js性能</tag>
        <tag>js面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程调试之代理服务器]]></title>
    <url>%2F2018%2F05%2F22%2Fngrok%2F</url>
    <content type="text"><![CDATA[接下来我们来介绍一下代理服务器的作用及常用的代理服务器工具 1. ngrok 官方文档 1234567# 作用1.本地开启小型服务器，方便调试，测试2.移动端调试# 使用方式1.全局安装2.ngrok http [想要代理的端口号]]]></content>
      <categories>
        <category>代理服务器</category>
      </categories>
      <tags>
        <tag>ngrok</tag>
        <tag>服务器代理</tag>
        <tag>移动端调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌常用]]></title>
    <url>%2F2018%2F05%2F22%2Fchrome%2F</url>
    <content type="text"><![CDATA[总结常用谷歌开发者工具 1.全屏截图 打开开发者工具 - ctrl+shift+p - 搜索关键字“screen”即可发现]]></content>
      <categories>
        <category>谷歌开发者工具</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>开发调试</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品笔记与一些思考]]></title>
    <url>%2F2018%2F05%2F19%2Fproduct%2F</url>
    <content type="text"><![CDATA[产品经理的一些探索和思考 1.精益产品的探索 找到天使用户（第一步）1.存在的问题或痛点2.知道他们自己存在的问题或痛点3.尝试寻找解决方案4.倒腾他自己的解决方案5.愿意并能够为解决方案付费你的目标是找到天使用户，而不是主流用户 121.细心观察生活的点滴，并尝试去探寻问题背后的答案2.一秒钟变成用户，感同身受 用户与场景痛点，用户访谈 1231. 消费者购买或使用产品大多基于情感需求2. 企业级消费者基于恐惧和贪婪购买产品3. 你真正的竞争对手，往往不是创业型企业或者各种门户型网站，而是用户线下的生活方式 问题背后的假设产生这个问题的各个可度量的要素用户访谈拒绝推销你的产品，让用户来谈谈他对某个方向的理解让用户讲他自己的故事 123// 问题告诉我你上一次有问题的情况或场景对你来说，解决那个问题的最佳方案是什么 走出办公楼 12// 推荐书籍《精益创业》《四不创业法》《创新者的窘境》《引爆点》《你的灯亮着吗》 在探索一个产品的复杂商业模式时，应该站在用户的角度去思考，解决用户遇到的问题成功的创业企业都是在资源耗尽之前经历了足够次数的迭代 2.产品经理基本功 产品服务流程 1场景-需求-功能 分析需求利器——马斯洛需求层次理论 123451.生理需求2.安全需求3.社交需求4.尊重需求5.自我实现需求 3.项目发布 1.测试 功能测试（TC) 回归测试（重复以前全部或部分测试） 适配测试（机型，操作系统，网络环境） 性能测试（电量，流量，cpu占用率等） 埋点测试 2.发布 1.灰度发布 目标：检验bug/性能指标/关键指标监控 ios,Android灰度渠道，周期不能太长，紧盯反馈和核心指标 2.APP发布渠道 IOS: App Store Android: 3.web,H5和服务端发布 1数据是评价指标的唯一标准 4.用户体验 组成： 硬件-技术-设计-功能-研究-交互伟大的体验来自用户的反思不要四不像，要做有个性和一致性的产品]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>Axure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习总结]]></title>
    <url>%2F2018%2F05%2F18%2Freact-summary%2F</url>
    <content type="text"><![CDATA[我的react爬坑笔记 1. 使用create-react-app执行npm run build时页面空白123// 解决方案在package.json内增加如下字段"homepage": "./" 2. 插值符号内不能使用引用类型，否则会报错3. render方法里return之前和return的数据时机不一样，并且return内必须返回一个闭合标签123456render()&#123; // 此时a获取的是初始化的数据，而不是更改后的数据 let a = this.a; // return内的a是componentDidMount后的数据 return (&lt;div&gt;不能为对象等引用类型&#123;a&#125;&lt;/div&gt;)&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-dedux</tag>
        <tag>react-router-dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面面俱到——不足点总结]]></title>
    <url>%2F2018%2F04%2F26%2Fface-summary%2F</url>
    <content type="text"><![CDATA[过往一些不足的地方，通过博客，好好总结一下。 前端常见问题总结1.css禁用鼠标事件12345.disabled &#123; pointer-events: none; cursor: default; opacity: 0.6;&#125; 2.get/post的理解和他们之间的区别http 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。HTTP 的工作方式是客户机与服务器之间的请求-应答协议。web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 http方法： HEAD: 与 GET 相同，但只返回 HTTP 报头，不返回文档主体PUT: 上传指定的 URI 表示DELETE: 删除指定资源OPTIONS: 返回服务器支持的 HTTP 方法CONNECT: 把请求连接转换到透明的 TCP/IP 通道POST: 向指定的资源提交要被处理的数据 1234// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 GET: 从指定的资源请求数据 GET和POST的区别 GET 请求可被缓存GET 请求保留在浏览器历史记录中GET 请求可被收藏为书签GET 请求不应在处理敏感数据时使用GET 请求有长度限制(2048字符),IE和Safari浏览器限制2k;Opera限制4k;Firefox，Chrome限制8kGET 请求只应当用于取回数据 POST 请求不会被缓存POST 请求不会保留在浏览器历史记录中POST 不能被收藏为书签POST 请求对数据长度没有要求 3.实现条纹网格的方式 nth-child(even/odd) 1234// odd表示基数，此时选中基数行的样式，even表示偶数行.row:nth-child(odd)&#123; background: #eee;&#125; nth-of-type(odd) 123.row:nth-of-type(odd)&#123; background: #eee;&#125; 渐变实现linear-gradient 12345678.stripe-bg&#123; padding: .5em; line-height: 1.5em; background: beige; background-size: auto 3em; background-origin: content-box; background-image: linear-gradient(rgba(0,0,0,.2) 50%, transparent 0);&#125; 4.js求平面两点之间的距离12345678// 数据可以以数组方式存储，也可以是对象方式let a = &#123;x:'6', y:10&#125;, b = &#123;x: 8, y: 20&#125;; function distant(a,b)&#123; let dx = Number(a.x) - Number(b.x) let dy = Number(a.y) - Number(b.y) return Math.pow(dx*dx + dy*dy, .5) &#125; 5.css禁止用户选择12345678body&#123;-webkit-touch-callout: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;&#125; 6.数组去重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// indexOf实现var array = [1, 1, '1'];function unique(array) &#123; var res = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i]; if (res.indexOf(current) === -1) &#123; res.push(current) &#125; &#125; return res;&#125;console.log(unique(array));// 排序后去重var array = [1, 1, '1'];function unique(array) &#123; var res = []; var sortedArray = array.concat().sort(); var seen; for (var i = 0, len = sortedArray.length; i &lt; len; i++) &#123; // 如果是第一个元素或者相邻的元素不相同 if (!i || seen !== sortedArray[i]) &#123; res.push(sortedArray[i]) &#125; seen = sortedArray[i]; &#125; return res;&#125;console.log(unique(array));// filter实现var array = [1, 2, 1, 1, '1'];function unique(array) &#123; var res = array.filter(function(item, index, array)&#123; return array.indexOf(item) === index; &#125;) return res;&#125;console.log(unique(array));// 排序去重var array = [1, 2, 1, 1, '1'];function unique(array) &#123; return array.concat().sort().filter(function(item, index, array)&#123; return !index || item !== array[index - 1] &#125;)&#125;console.log(unique(array));// Object键值对var array = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;];function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; console.log(typeof item + JSON.stringify(item)) return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) &#125;)&#125;console.log(unique(array)); // [&#123;value: 1&#125;, &#123;value: 2&#125;]// ES6 Set实现var unique = (a) =&gt; [...new Set(a)] 7.什么是CDN和CDN的好处 CDN:CDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。好处：1、多域名加载资源一般情况下，浏览器都会对单个域名下的并发请求数（文件加载）进行限制，通常最多有4个，那么第5个加载项将会被阻塞，直到前面的某一个文件加载完毕。因为CDN文件是存放在不同区域（不同IP）的，所以对浏览器来说是可以同时加载页面所需的所有文件（远不止4个），从而提高页面加载速度。 2、文件可能已经被加载过并保存有缓存一些通用的js库或者是css样式库，如jQuery，在网络中的使用是非常普遍的。当一个用户在浏览你的某一个网页的时候，很有可能他已经通过你网站使用的CDN访问过了其他的某一个网站，恰巧这个网站同样也使用了jQuery，那么此时用户浏览器已经缓存有该jQuery文件（同IP的同名文件如果有缓存，浏览器会直接使用缓存文件，不会再进行加载），所以就不会再加载一次了，从而间接的提高了网站的访问速度 3、高效率你的网站做的再NB也不会NB过百度NB过Google吧？一个好的CDNs会提供更高的效率，更低的网络延时和更小的丢包率。 4、分布式的数据中心假如你的站点布置在北京，当一个香港或者更远的用户访问你的站点的时候，他的数据请求势必会很慢很慢。而CDNs则会让用户从离他最近的节点去加载所需的文件，所以加载速度提升就是理所当然的了。 5、使用情况分析一般情况下CDNs提供商（如百度云加速）都会提供数据统计功能，可以了解更多关于用户访问自己网站的情况，可以根据统计数据对自己的站点适时适当的做出些许调整。 6、有效防止网站被攻击一般情况下CDNs提供商也是会提供网站安全服务的 8.圣杯布局和双飞翼布局 参考连接 9.正则表达式匹配手机号123456function checkPhone()&#123; if(!(/^1[34578]\d&#123;9&#125;$/.test(phone)))&#123; alert("手机号码有误，请重填"); return false; &#125;&#125; 10.如何提高首频加载速度 1.js外联文件放到body底部，css外联文件放到head内2.http静态资源尽量用多个子域名3.服务器端提供html和http静态资源时最好开启gzip4.在js,css,img等资源响应的http headers里设置expires,last-modified5.尽量减少http requests的数量6.js/css/html/img资源压缩7.使用css spirtes，可以减少img请求次数8.大图使用lazyload懒加载9.避免404，减少外联js10.减少cookie大小可以提高获得响应的时间11.减少dom elements的数量12.使用异步脚本，动态创建脚本 11.浏览器内核(渲染引擎) IE/360/搜狗浏览器: TridentChrome/Safari/Opera: WebKit(KHTML的一个开源的分支)(虽然我们称WebKit为浏览器内核，但不太适合直接称渲染引擎，因为WebKit本身主要是由两个引擎构成的，一个正是渲染引擎“WebCore”，另一个则是javascript解释引擎“JSCore”，它们均是从KDE的渲染引擎KHTML及javascript解释引擎KJS衍生而来。)(在13年发布的Chrome 28.0.1469.0版本开始，Chrome放弃Chromium引擎转而使用最新的Blink引擎（基于WebKit2——苹果公司于2010年推出的新的WebKit引擎），Blink对比上一代的引擎精简了代码、改善了DOM框架，也提升了安全性。)(为了减少研发成本，Opera在2013年2月宣布放弃Presto，转而跟随Chrome使用WebKit分支的Chromium引擎作为自家浏览器核心引擎)Firefox/SeaMonkey: Gecko 12.浏览器渲染过程及优化建议 1）解析：一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。 CSS，解析CSS会产生CSS规则树。 Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.2）渲染：浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。 CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。 然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。3）绘制：最后通过调用操作系统Native GUI的API绘制。 减少reflow和repaint1）不要一条一条地修改DOM的样式。还不如预先定义好css的class，然后修改DOM的className。2) 把DOM离线后修改。如：使用documentFragment 对象在内存里操作DOM 先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。 clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。3）不要把DOM结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性4）为动画的HTML元件使用fixed或absoulte的position，尽量使用transfoem，那么修改他们的CSS是不会reflow的5）尽量少使用table布局。因为可能很小的一个小改动会造成整个table的重新布局 13. 页面导入样式时，使用link和@import有什么区别？ （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; (4)link支持使用js控制DOM去改变样式，而@import不支持; 14. 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 15. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 16. iframe有那些缺点？iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO;*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 17. vue父子组件生命周期的顺序及作用？18. 网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 19. 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ （1）有两种， IE 盒子模型、W3C 盒子模型； （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； （3）区 别： IE的content部分把 border 和 padding计算了进去; 20. position的值relative和absolute定位原点是？ absolute生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其正常位置进行定位。static默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。inherit规定从父元素继承 position 属性的值。 21. 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——display:inline;将其转化为行内属性。(这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb{ background-color:red;/*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ } IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。 IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 22. CSS优化、提高性能的方法有哪些？ 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 23. 如何修改chrome记住密码后自动填充表单的黄色背景 ？12345input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123; background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0); &#125; 24. 让页面里的字体变清晰，变细用CSS怎么做？1-webkit-font-smoothing: antialiased; 25. 让overflow:scroll平滑滚动？1-webkit-overflow-scrolling: touch; 26. 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?1234567function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1, $2)&#123; return $2 + ','; &#125;); &#125; 27. Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。 28. 谈谈This对象的理解。 this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； 29. eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’); 30. 什么是window对象? 什么是document对象? window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。 31. [“1”, “2”, “3”].map(parseInt) 答案是多少？ [“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN] 32. 什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 33. javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 保证代码运行的安全,限制函数中的arguments修改; 提高编译器效率，增加运行速度； 34. 如何判断一个对象是否属于某个类？ 123456789101112131415161718if(a instanceof Person)&#123; alert('yes');&#125;// 判断对象类型最好的方式// 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 35. new一个对象的过程1231、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到 this 引用的对象中。3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 36. Ajax 解决浏览器缓存问题 1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。3、在URL后面加上一个随机数： “fresh=” + Math.random();。4、在URL后面加上时间戳：”nowtime=” + new Date().getTime();。5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 37. 如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 38. 模块化开发怎么做 立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 39. AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。 CMD 推崇依赖就近，AMD 推崇依赖前置。 1234567891011121314151617// CMD define(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) // AMD 默认推荐 define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... &#125;) 40. requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？） 参考链接 41. 如何实现一个模块加载器 参考连接 42. 列举几条 JavaScript 的基本代码规范 （1）不要在同一行声明多个变量（2）如果你不知道数组的长度，使用 push（3）请使用 ===/!== 来比较 true/false 或者数值（4）对字符串使用单引号 ‘’(因为大多时候我们的字符串。特别html会出现”)（5）使用对象字面量替代 new Array 这种形式（6）绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同（7）不要使用全局函数（8）总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间（9）Switch 语句必须带有 default 分支（10）使用 /*…/ 进行多行注释，包括描述，指定类型以及参数值和返回值（11）函数不应该有时候有返回值，有时候没有返回值（12）语句结束一定要加分号（13）for 循环必须使用大括号（14）if 语句必须使用大括号（15）for-in 循环中的变量应该使用 var 关键字明确限定作用域，从而避免作用域污染（16）避免单个字符名，让你的变量名有描述意义（17）当命名对象、函数和实例时使用驼峰命名规则（18）给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题 43. DOM操作——怎样添加、移除、移动、复制、创建和查找节点? 1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 44. jquery实现原理 参考链接 45. jquery中如何将数组转化为json字符串，然后再转化回来？1234567891011jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展： $.fn.stringifyArray = function(array) &#123; return JSON.stringify(array) &#125; $.fn.parseArray = function(array) &#123; return JSON.parse(array) &#125; 然后调用： $.fn.stringifyArray(array) 46. jquery的$.extend深复制和浅复制原理12345678910111213141516171819202122232425262728293031323334// 浅复制$ = &#123; extend : function(target, options) &#123; for (name in options) &#123; target[name] = options[name]; &#125; return target; &#125; &#125;; // 深复制$ = &#123; extend : function(deep, target, options) &#123; for (name in options) &#123; copy = options[name]; if (deep &amp;&amp; copy instanceof Array) &#123; target[name] = $.extend(deep, [], copy); &#125; else if (deep &amp;&amp; copy instanceof Object) &#123; target[name] = $.extend(deep, &#123;&#125;, copy); &#125; else &#123; target[name] = options[name]; &#125; &#125; return target; &#125;&#125;; 47. jquery.extend 与 jquery.fn.extend的区别？ jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 jquery.fn.extend: 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数使用：jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。 48. 如何判断当前脚本运行在浏览器还是node环境中？（阿里） 1this === window ? 'browser' : 'node'; 49. 实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？ 参考链接 50. 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？ 之前推荐的方法（已过时）：之前解决这个问题的方法是把 标签放到标签之后 ，这确保了解析到之前都不会被script终端。这个方法是有问题的: 浏览器在整个文档解析完成之前都不能下载script文件，如果文档很大的话，解析完HTML，用户依然要等待script文件下载并执行完成之后，才能操作这个网站。 现在推荐的解决方案：现在浏览器script标签支持 async 和 defer 属性. 应用这些属性当script被下载时，浏览器更安全而且可以并行下载（下载script并不阻断HTML解析）。1.async标记的Script异步执行下载，并执行。这意味着script下载时并不阻塞HTML的解析，并且下载结束script马上执行。2.defer标签的script顺序执行。这种方式也不会阻断浏览器解析HTML。跟 async不同, defer scripts在整个文档里的script都被下载完才顺序执行。 51. JQuery一个对象可以同时绑定多个事件，这是如何实现的？1234567//多个事件同一个函数： $("div").on("click mouseover", function()&#123;&#125;);//多个事件不同函数 $("div").on(&#123; click: function()&#123;&#125;, mouseover: function()&#123;&#125; &#125;); 52. 什么是前端路由？前端路由的 实现原理 参考链接 53. 检测浏览器版本版本有哪些方式？12345功能检测、userAgent特征检测比如：navigator.userAgent//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36" 54. 什么是Polyfill? polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。 例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象， 所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发， 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 55. 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？ html5shiv、Geolocation、Placeholder 56. 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？ 按照W3C的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 1234567891011121314151617// div-capture &gt; btn-bubble &gt; btn-capture &gt; div-bubblevar btn = document.querySelector('button');var div = document.querySelector('div');btn.addEventListener('click', function()&#123; console.log('bubble','btn');&#125;,false);btn.addEventListener('click', function()&#123; console.log('capture','btn');&#125;,true);div.addEventListener('click', function()&#123; console.log('bubble','div');&#125;,false);div.addEventListener('click', function()&#123; console.log('capture','div');&#125;,true); 57. Webpack热更新实现原理? Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信) 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档 hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。 58. 函数节流和防抖 参考链接 59. 页面重构怎么操作？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 60. 列举IE与其他浏览器不一样的特性 事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()； 61. 对Node的优点和缺点提出了自己的看法？ *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 62. 你有用过哪些前端性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。 63. http 1**(信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 2**(响应成功)：表示动作被成功接收、理解和接受 200——表明该请求被成功地完成，所请求的资源发送回客户端 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 3**(重定向类)：为了完成指定的动作，必须接受进一步处理 300——请求的资源可在多处得到 301——本网页被永久性转移到另一个URL 302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。 303——建议客户访问其他URL或访问方式 304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 4**(客户端错误类)：请求包含错误语法或不能正确执行 400——客户端请求有语法错误，不能被服务器所理解 401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 HTTP 401.1 - 未授权：登录失败 HTTP 401.2 - 未授权：服务器配置问题导致登录失败 HTTP 401.3 - ACL 禁止访问资源 HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 402——保留有效ChargeTo头响应 403——禁止访问，服务器收到请求，但是拒绝提供服务 HTTP 403.1 禁止访问：禁止可执行访问 HTTP 403.2 - 禁止访问：禁止读访问 HTTP 403.3 - 禁止访问：禁止写访问 HTTP 403.4 - 禁止访问：要求 SSL HTTP 403.5 - 禁止访问：要求 SSL 128 HTTP 403.6 - 禁止访问：IP 地址被拒绝 HTTP 403.7 - 禁止访问：要求客户证书 HTTP 403.8 - 禁止访问：禁止站点访问 HTTP 403.9 - 禁止访问：连接的用户过多 HTTP 403.10 - 禁止访问：配置无效 HTTP 403.11 - 禁止访问：密码更改 HTTP 403.12 - 禁止访问：映射器拒绝访问 HTTP 403.13 - 禁止访问：客户证书已被吊销 HTTP 403.15 - 禁止访问：客户访问许可过多 HTTP 403.16 - 禁止访问：客户证书不可信或者无效 HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。 5**(服务端错误类)：服务器不能正确执行一个正确的请求 HTTP 500 - 服务器遇到错误，无法完成请求 HTTP 500.100 - 内部服务器错误 - ASP 错误 HTTP 500-11 服务器关闭 HTTP 500-12 应用程序重新启动 HTTP 500-13 - 服务器太忙 HTTP 500-14 - 应用程序无效 HTTP 500-15 - 不允许请求 global.asa Error 501 - 未实现 HTTP 502 - 网关错误 HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常 64. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等； 详细版： 1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 4、进行HTTP协议会话，客户端发送报头(请求报头); 5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 65. 前端学习资源 js秘密花园jquery原理解析css3js标准 66. 邮箱验证1var pattern = /^([A-Za-z0-9_\-\.\u4e00-\u9fa5])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,8&#125;)$/; 参考链接 67. ajax实现原理及方法使用123456789101112readyState属性有五个状态值。0：是uninitialized，未初始化。已经创建了XMLHttpRequest对象但是未初始化。1：是loading.已经开始准备好要发送了。2：已经发送，但是还没有收到响应。3：正在接受响应，但是还不完整。4：接受响应完毕。responseText：服务器返回的响应文本。只有当readyState&gt;=3的时候才有值，根据readyState的状态值，可以知道，当readyState=3，返回的响应文本不完整，只有readyState=4，完全返回，才能接受全部的响应文本。responseXML：response as Dom Document object。响应信息是xml，可以解析为Dom对象。status：服务器的Http状态码，若是200，则表示OK，404，表示为未找到。statusText：服务器http状态码的文本。比如OK，Not Found。 参考链接 68. js实现继承参考链接 69. 用generator实现es7的async12 70. 闭包使用的优缺点 优点：1.保护函数内部变量的安全，加强了封装性2.在内存中维持一个变量3.设计私有方法和变量4.可以读取函数内部的变量缺点：1.导致内存泄漏，使用不当会造成额外的内存占用2.可以改变父函数的变量，所以使用时要谨慎 71. canvas和svg区别 1.从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。可以简单的把两者的区别看成photoshop与illustrator的区别。2.从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。3.从操作对象上说，Canvas是基于HTML canvas标签，通过宿主提供的Javascript API对整个画布进行操作的，而SVG则是基于XML元素的。4.从功能上讲，SVG发布日期较早，所以功能相对Canvas比较完善。5.关于动画，Canvas更适合做基于位图的动画，而SVG则适合图表的展示。6.从搜索引擎角度分析，由于svg是有大量标签组成，所以可以通过给标签添加属性，便于爬虫搜索]]></content>
      <tags>
        <tag>js css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6总结]]></title>
    <url>%2F2018%2F04%2F18%2Fes6%2F</url>
    <content type="text"><![CDATA[ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。ES6给我们提供了很多js的新特性和规范，使得我们编写Js代码更加灵活和强大，接下来让我们来学习一下吧。 let和constlet声明的变量只在它所在的代码块有效。for循环计数很适合此变量123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 不存在变量提升ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。let不允许在相同作用域内，重复声明同一个变量考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错 const声明一个只读的常量。一旦声明，常量的值就不能改变 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心 123456789// 将对象彻底冻结var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 变量的解构赋值解构赋值允许指定默认值12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构 数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值 123456789101112// p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量 1let &#123; log, sin, cos &#125; = Math; 字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象 12345678910const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o"// 获取字符串长度let &#123;length : len&#125; = 'hello';len // 5 字符串扩展字符基础 JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。汉字“𠮷”的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 字符串的遍历器接口 ES6 为字符串添加了遍历器接口,使得字符串可以被for…of循环遍历。 includes(), startsWith(), endsWith() includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let d = 'Hello world!';// 第二个参数表示开始搜索的位置，endsWith第二个参数不同，针对前n个字符d.startsWith('world', 6) // trued.endsWith('hello', 5) // trued.includes('Hello', 6) // false repeat() repeat方法返回一个新字符串，表示将原字符串重复n次如果repeat的参数是负数或者Infinity，会报错。如果repeat的参数是字符串，则会先转换成数字参数NaN等同于 0 123'hello'.repeat(2) // "hellohello"'na'.repeat(0) // ""'aa'.repeat(2.3) // 'aaaa' 参数如果是小数会被取整 padStart()，padEnd() 字符串补全12345678'x'.padStart(5, 'ab') // 'ababx''x'.padEnd(4, 'ab') // 'xaba'// 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串'ssss'.padStart(3,'dd') // 'ssss'// 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串'abc'.padStart(10, '0123456789') // '0123456abc'// 如果省略第二个参数，默认使用空格补全长度'ss'.padStart(10) // ' ss' 模板字符串 ${} 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性模板字符串之中还能调用函数 123456789101112131415161718192021222324// 简单的模板函数const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`;const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 标签模板 tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推 123456789101112131415161718let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; let result = ''; let i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // "The total is 30 (31.5 with tax)" “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; String.raw() String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用 123456String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 "Hi\\n5!"`Hi\n$&#123;2+3&#125;!` // 此时换行符/n会生效// 返回 "Hi// n5!" 正则的扩展u 修饰符 ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码 y 修饰符 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 12'a1a2a3'.match(/a\d/y) // ["a1"]'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 123456789101112131415161718192021const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;const TOKEN_G = /\s*(\+|[0-9]+)\s*/g;tokenize(TOKEN_Y, '3 + 4')// [ '3', '+', '4' ]tokenize(TOKEN_G, '3 + 4')// [ '3', '+', '4' ]function tokenize(TOKEN_REGEX, str) &#123; let result = []; let match; while (match = TOKEN_REGEX.exec(str)) &#123; result.push(match[1]); &#125; return result;&#125;tokenize(TOKEN_Y, '3x + 4')// [ '3' ]tokenize(TOKEN_G, '3x + 4')// [ '3', '+', '4' ] sticky 属性 表示是否设置了y修饰符 ,返回true/false flags 属性 返回正则表达式的修饰符 如何让 . 匹配包括换行符(行终止符)的所有字符123456//U+000A 换行符（\n）//U+000D 回车符（\r）//U+2028 行分隔符（line separator）//U+2029 段分隔符（paragraph separator）/foo[^]bar/.test('foo\nbar') // true ES5先行断言 ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。 ES5组匹配 正则表达式使用圆括号进行组匹配 123456const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 数值扩展Number.isFinite() Number.isFinite()用来检查一个数值是否为有限的（finite）,如果参数类型不是数值，一律返回false Number.isNaN() 用来检查一个值是否为NaN Number.parseInt(), Number.parseFloat() ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 Number.isInteger() Number.isInteger()用来判断一个数值是否为整数。如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数, 12// 由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。Number.isInteger(3.0000000000000002) // true Number.EPSILON 在Number对象上，新增一个极小的常量Number.EPSILON。它表示 1 与大于 1 的最小浮点数之间的差Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了 1234567// Number.EPSILON可以用来设置“能够接受的误差范围”function withinErrorMargin (express, right) &#123; return Math.abs(express) &lt; Number.EPSILON * Math.pow(2, 2);&#125;0.1 + 0.2 === 0.3 // falsewithinErrorMargin(0.1 + 0.2, 0.3) // true 安全整数和 Number.isSafeInteger() JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内 Math 对象的扩展Math.trunc() Math.trunc方法用于去除一个数的小数部分，返回整数部分对于空值和无法截取整数的值，返回NaN对于非数值，Math.trunc内部使用Number方法将其先转为数值 1234// 对于没有部署这个方法的环境，可以用下面的代码模拟Math.trunc = Math.trunc || function(x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.hypot() 返回所有参数的平方和的平方根 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 指数运算符（**） 注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。 123456789let a = 1.5;a **= 2;// 等同于 a = a * a;Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197 函数扩展函数参数的默认值1234function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125; 参数默认值的位置 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 函数的 length 属性 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123456789(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2// rest 参数不会计入length属性(function(...args) &#123;&#125;).length // 0// 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 箭头函数 大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 this指向的固定化 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数 尾调用优化 调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数 123function f(x)&#123; return g(x);&#125; 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 12345678910111213141516下面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 尾递归优化 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 蹦床函数12345678910111213141516function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125;// 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;trampoline(sum(1, 100000)) 真正的尾递归优化1234567891011121314151617181920212223242526272829unction tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 数组的扩展1.扩展运算符 将一个数组转为用逗号分隔的参数序列。如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 替代函数的 apply 方法12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 复制数组12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 合并数组12345678910var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3] 与解构赋值结合1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 字符串 JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题凡是涉及到操作四个字节的 Unicode 字符的函数，最好都用扩展运算符改写。 12[...'hello']// [ "h", "e", "l", "l", "o" ] Array.from() Array.from方法用于将类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 123456789101112131415161718192021222324let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 1234567891011121314151617// Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);// 取出一组 DOM 节点的文本内容let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent)// 将数组中布尔值为false的成员转为0Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 123// Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] Array.of() 用于将一组值转化为数组 12345678Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1// 可以用以下方法模拟function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 copyWithin() 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组 12345678// 参数说明// target（必需）：从该位置开始替换数据。如果为负值，表示倒数。// start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。这两个方法都可以接受第二个参数，用来绑定回调函数的this对象 1234567891011121314151617181920212223// find[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10// findIndex[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2// 第二个参数function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26// indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 数组实例的 fill() ill方法使用给定值，填充一个数组 123456789101112['a', 'b', 'c'].fill(7)// [7, 7, 7]// fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c']// 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。let arr = new Array(3).fill(&#123;name: "Mike"&#125;);arr[0].name = "Ben";arr// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;] 数组实例的 entries()，keys() 和 values() ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 123456// 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes() 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似 123456789101112131415[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true// 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true// 兼容写法const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 数组的空位 数组的空位指，数组的某一个位置没有任何值,ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位,ES6 则是明确将空位转为undefined 对象扩展属性的赋值器与取值器的简洁写法 简洁写法的属性名总是字符串,所以说属性中有关键字也不会报错 123456789101112131415161718192021const cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('数值太小了！'); &#125; this._wheels = value; &#125;&#125;//如果是个遍历器，前面需要加一个星号const obj = &#123; * m() &#123; yield 'hello world'; &#125;&#125;; Object.is() 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身 1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。如果只有一个参数，Object.assign会直接返回该参数如果该参数不是对象，则会先转成对象，然后返回由于undefined和null无法转成对象，所以如果它们作为参数，就会报错 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错 123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果因为只有字符串的包装对象，会产生可枚举属性 123456const v1 = 'abc';const v2 = true;const v3 = 10;const obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; "0": "a", "1": "b", "2": "c" &#125; 注意点 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用于嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加Object.assign可以用来处理数组，但是会把数组视为对象Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制 1234567onst source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125; 常见用途 为对象添加属性 123456class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); // 等价于 this.x = x; this.y = y &#125;&#125; 为对象添加方法 12345678Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;); 合并多个对象 12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 为属性指定默认值 12345678910111213141516171819202122const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125;// 注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。const DEFAULTS = &#123; url: &#123; host: 'example.com', port: 7070 &#125;,&#125;;processContent(&#123; url: &#123;port: 8000&#125; &#125;)// &#123;// url: &#123;port: 8000&#125;// &#125; Object.setPrototypeOf() 用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法 12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 Object.getPrototypeOf() 用来读取一个对象的原型 super 关键字 指向当前对象的原型对象 12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法） Object.keys ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用 1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; symbol ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object） 123456789// Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分let s1 = Symbol('foo');let s2 = Symbol();s1 // Symbol(foo)s2 // Symbol()s1.toString() // "Symbol(foo)"s2.toString() // "" Symbol 值不能与其他类型的值进行运算,否则会报错Symbol 值可以显式转为字符串 12let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)' 属性名的遍历 ymbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// ["enum", "nonEnum", Symbol(my_key)] Symbol.for()，Symbol.keyFor() 有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值ymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 1234567891011let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true// Symbol.keyFor方法返回一个已登记的 Symbol 类型值的keylet s1 = Symbol.for("foo");Symbol.keyFor(s1) // "foo"// s2未登记，所以返回undefinedlet s2 = Symbol("foo");Symbol.keyFor(s2) // undefined 需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值 Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构 12345678const s = new Set();// add方法用来向Set里面添加数据[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化 123456789101112// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll('div'));set.size // 56 在 Set 内部，两个NaN是相等另外，两个对象总是不相等的 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 Set 实例的属性和方法Set 结构的实例的属性 Set.prototype.constructor：构造函数，默认就是Set函数。Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）操作方法 add(value)：添加某个值，返回 Set 结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值。 123456// 去除数组重复成员的另一种方法function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作 keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值，所以keys方法和values方法的行为完全一致。 12345678910111213for (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"]//forEach() 对某个成员执行某种操作set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 应用 扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构 12345678910111213141516171819202122232425// 转换为数组let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue']//数组去重let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2]// 实现交集，并集，差集let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; Map ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。 1234567891011//Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1const m2 = new Map([['baz', 3]]);const m3 = new Map(m2);m3.get('baz') // 3 Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名 实例的属性和操作方法 （1）size 属性属性返回 Map 结构的成员总数（2）set(key, value)set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键（3）get(key)get方法读取key对应的键值，如果找不到key，返回undefined（4）has(key)has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中（5）delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。（6）clear()clear方法清除所有成员，没有返回值 Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤 1234567891011121314const map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');const map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;const map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 此外，Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历 1234map.forEach(function(value, key, map) &#123; console.log("Key: %s, Value: %s", key, value);&#125;);// forEach方法还可以接受第二个参数，用来绑定this WeakMap WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名WeakMap的键名所指向的对象，不计入垃圾回收机制WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 应用 向dom节点存入数据 12345678910let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false);// 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 WeakMap 的另一个用处是部署私有属性 123456789101112131415161718192021222324const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;const c = new Countdown(2, () =&gt; console.log('DONE'));c.dec()c.dec()// DONE Promise Promise是一种异步编程的解决方案。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 图片异步加载function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125;// 封装ajaxconst getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 Promise.prototype.then() then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 Promise.prototype.finally()Promise.all() Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 1234567891011// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + ".json");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;);// 只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法 Promise.race() Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例只要有一个实例率先改变状态，Promise.race的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给Promise.race的回调函数。 1234567891011// 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolveconst p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); Promise.resolve() 将现有对象转为 Promise 对象 12345678// （1）参数是一个 Promise 实例如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。// 参数是一个thenable对象Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。// （3）参数不是具有then方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved// （4）不带有任何参数直接返回一个resolved状态的 Promise 对象。 需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three Generator函数的异步应用 1.异步：所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); 2.Thunkify 模块 12345678// npm install thunkifyvar thunkify = require('thunkify');var fs = require('fs');var read = thunkify(fs.readFile);read('package.json')(function(err, str)&#123; // ...&#125;); async函数 async函数返回一个 Promise 对象async函数内部return语句返回的值，会成为then方法回调函数的参数async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到 123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 Promise 对象的状态变化: async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。 await 命令: 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象 12345// 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 下面的例子使用try…catch结构，实现多次重复尝试 123456789101112131415const superagent = require('superagent');const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get('http://google.com/this-throws-an-error'); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test();]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能JS]]></title>
    <url>%2F2018%2F04%2F04%2Fjs-high-pf%2F</url>
    <content type="text"><![CDATA[javascript在浏览器中运行的性能，可以认为是开发者所面临的最严重的可用性问题。这个问题因为javascript的阻塞性而变得复杂，事实上，多数浏览器使用单一进程来处理用户界面和js脚本执行，所以同一时刻只能做一件事。js执行过程耗时越久，浏览器等待响应的时间越长。 加载和执行1.提高加载性能 1.IE8,FF,3.5,Safari 4和Chrome都允许并行下载js文件，当script下载资源时不会阻塞其他script的下载。但是js下载仍然会阻塞其他资源的下载，如图片。尽管脚本下载不会互相影响，但页面仍然必须等待所有js代码下载并执行完才能继续。因此仍然存在脚本阻塞问题.推荐将所有js文件放在body标签底部以减少对整个页面的影响。 2.减少页面外链脚本文件的数量将会提高页面性能：http请求会带来额外的开销，因此下载单个300k的文件将比下载10个30k的文件效率更高。 3.动态脚本加载技术：无论何时启动下载，文件的下载和执行都不会阻塞页面其他进程。 12345678910111213141516171819202122232425262728function laodScript(url,callback)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; if(script.readyState)&#123; // ie script.onreadystatechange = function()&#123; if(script.readyState == 'loaded' || script.readyState == 'complete')&#123; script.onreadystatechange = null; callback() &#125; &#125; &#125;else&#123; //其他浏览器 script.onload = function()&#123; callback() &#125; &#125; script.src = url; document.getElementsByTagName('head')[0].appendChild(script);&#125;// 使用loadScript('./a.js',function()&#123; loadScript('./b.js',function()&#123; loadScript('./c.js',function()&#123; console.log('加载完成') &#125;) &#125;)&#125;) 4.无阻塞加载类库——LABjs,使用方法如下： 1234567891011121314&lt;script src="lab.js"&gt;&lt;/script&gt;// 链式调用时文件逐个下载，.wait()用来指定文件下载并执行完毕后所调用的函数$LAB.script('./a.js') .script('./b.js') .wait(function()&#123; App.init();&#125;)// 为了保证执行顺序，可以这么做,此时a必定在b前执行$LAB.script('./a.js').wait() .script('./b.js') .wait(function()&#123; App.init();&#125;) 2.数据存取与JS性能 1.在js中，数据存储的位置会对代码整体性能产生重大影响。数据存储共有4种方式：字面量，变量，数组项，对象成员。他们有着各自的性能特点。 2.访问字面量和局部变量的速度最快，相反，访问数组和对象相对较慢3.由于局部变量存在于作用域联的起始位置，因此访问局部变量的比访问跨域作用变量更快4.嵌套的对象成员会明显影响性能，应尽量避免5.属性和方法在原型链位置越深，访问他的速度越慢6.通常我们可以把需要多次使用的对象成员，数组元素，跨域变量保存在局部变量中来改善js性能 3.DOM编程 1.访问DOM会影响浏览器性能，修改DOM则更耗费性能，因为他会导致浏览器重新计算页面的几何变化。&lt;通常的做法是减少访问DOM的次数，把运算尽量留在JS这一端。 注：如过在一个对性能要求比较高的操作中更新一段HTML，推荐使用innerHTML，因为它在绝大多数浏览器中运行的都很快。但对于大多数日常操作而言，并没有太大区别，所以你更应该根据可读性，稳定性，团队习惯，代码风格来综合决定使用innerHTML还是createElement() 2.HTML集合优化 HTML集合包含了DOM节点引用的类数组对象，一直与文档保持连接，每次你需要最新的信息时，都会重复执行查询操作，哪怕只是获取集合里元素的个数。 1.优化一——集合转数组collToArr 123456function collToArr(coll)&#123; for(var i=0, a=[], len=coll.length; i&lt;len; i++)&#123; a.push(coll[i]); &#125; return a&#125; 2.缓存集合length3.访问集合元素时使用局部变量（即将重复的集合访问缓存到局部变量中，用局部变量来操作） 3.遍历DOM 1.使用只返回元素节点的API遍历DOM,因为这些API的执行效率比自己实现的效率更高： 属性名被替代属性 childrenchildNodes childElementCountchildNodes.length firstElementChildfirstChild lastElementChildlastChild nextElementSiblingnextSibling previousElementSiblingpreviousSibling 2.选择器API——querySelectorAll() querySelectorAll()方法使用css选择器作为参数并返回一个NodeList——包含着匹配节点的类数组对象，该方法不会返回HTML集合，因此返回的节点不会对应实时文档结构，着也避免了HTML集合引起的性能问题。1let arr = document.querySelectorAll('div.warning, div.notice &gt; p') 4.重绘和重排 浏览器在下载完页面的所有组件——html,js,css,图片等之后，会解析并生成两个内部数据结构—— DOM树，渲染树.一旦DOM树和渲染树构建完成，浏览器就开始绘制页面元素（paint）. 1.重排发生的条件： 添加或删除可见的DOM元素位置变化元素尺寸改变内容改变页面渲染器初始化浏览器窗口尺寸变化出现滚动条时会触发整个页面的重排 重排必定重绘 5.渲染树变化的排列和刷新 大多数浏览器通过队列化修改并批量执行来优化重排过程，然而获取布局信息的操作会导致队列强制刷新。 1234offsetTop,offsetWidth...scrollTop,scrollHeight...clientTop,clientHeight...getComputedStyle() 一些优化建议：将设置样式的操作和获取样式的操作分开： 123456// 设置样式body.style.color = 'red';body.style.fontSize = '24px'// 读取样式let color = body.style.colorlet fontSize = body.style.fontSize 另外，获取计算属性的兼容写法： 1234function getComputedStyle(el)&#123; var computed = (document.body.currentStyle ? el.currentStyle : document.defaultView.getComputedStyle(el,''); return computed&#125; 6.最小化重绘和重排 1.批量改变样式 12/* 使用cssText */el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 20px'; 2.批量修改dom的优化方案——使元素脱离文档流-对其应用多重改变-把元素带回文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445function appendDataToEl(option)&#123; var targetEl = option.target || document.body, createEl, data = option.data || []; // 让容器脱离文档流，减少重绘重排 var targetEl_display = targetEl.style.display; targetEl.style.display = 'none'; // *****创建文档片段来优化Dom操作**** var fragment = document.createDocumentFragment(); // 给元素填充数据 for(var i=0, max = data.length; i&lt; max; i++)&#123; createEl = document.createElement(option.createEl); for(var item in data[i])&#123; if(item.toString() === 'text')&#123; createEl.appendChild(document.createTextNode(data[i][item])); continue; &#125; if(item.toString() === 'html')&#123; createEl.innerHTML = item,data[i][item]; continue; &#125; createEl.setAttribute(item,data[i][item]); &#125; // ****将填充好的node插入文档片段**** fragment.appendChild(createEl); &#125; // ****将文档片段统一插入目标容器**** targetEl.appendChild(fragment); // 显示容器，完成数据填充 targetEl.style.display = targetEl_display;&#125;// 使用var wrap = document.querySelectorAll('.wrap')[0];var data = [ &#123;name: 'xujaing',text: '选景', title: 'xuanfij'&#125;, &#123;name: 'xujaing',text: '选景', title: 'xuanfij'&#125;, &#123;name: 'xujaing',text: '选景', title: 'xuanfij'&#125;];appendDataToEl(&#123; target: wrap, createEl: 'div', data: data&#125;); 上面的优化方法使用了文档片段: 当我们把文档片段插入到节点中时，实际上被添加的只是该片段的子节点，而不是片段本身。可以使得dom操作更有效率。 3.缓存布局信息 1234567//缓存布局信息let current = el.offsetLeft;current++;el.style.left = current + 'px';if(current &gt; 300)&#123; stop();&#125; 4.慎用:hover 如果有大量元素使用:hover,那么会降低相应速度，CPU升高 5.使用事件委托（通过事件冒泡实现）来减少事件处理器的数量，减少内存和处理时间 1234567891011121314151617function delegation(e,selector,callback)&#123; e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName !== selector || target.className !== selector || target.id !== selector)&#123; return; &#125; if(typeof e.preventDefault === 'function')&#123; e.preventDefault(); e.stopPropagation(); &#125;else&#123; e.returnValue = false; e.cancelBubble = true; &#125; callback()&#125; 4.算法和流程控制 1.循环中减少属性查找并反转(可以提升50%-60%的性能) 123456789// for 循环for(var i=item.length; i--)&#123; process(item[i]);&#125;// while循环var j = item.length;while(j--)&#123; process(item[i]);&#125; 2.使用Duff装置来优化循环（该方法在后面的文章中会详细介绍） 3.基于函数的迭代（比基于循环的迭代慢） 123items.forEach(function(value,index,array)&#123; process(value);&#125;) 4.通常情况下switch总比if-else快，但是不是最佳方案 5.字符串和正则表达式 1.除了IE外，其他浏览器会尝试为表达式左侧的字符串分配更多的内存，然后简单的将第二个字符串拷贝到他的末尾，如果在一个循环中，基础字符串位于最左侧，就可以避免重复拷贝一个逐渐变大的基础字符串。2.使用[\s\S]来匹配任意字符串3.去除尾部空白的常用做法： 12345if(!String.prototype.trim)&#123; String.prototype.trim = function()&#123; return this.replace(/^\s+/,'').replace(/\s\s*$/, '') &#125;&#125; 6.快速响应的用户界面 1.浏览器的UI线程：用于执行javascript和更新用户界面的进程。 2.在windows系统中定时器分辨率为15毫秒，因此设置小于15毫秒将会使IE锁定，延时的最小值建议为25ms. 3.用延时数组分割耗时任务： 1234567891011121314function multistep(steps,args,callback)&#123; var tasks = steps.concat(); setTimeout(function()&#123; var task = tasks.shift(); task.apply(null, args || []); //调用Apply参数必须是数组 if(tasks.length &gt; 0)&#123; setTimeout(arguments.callee, 25); &#125;else&#123; callback(); &#125; &#125;,25);&#125; 4.记录代码运行时间批处理任务： 1234567891011121314151617function timeProcessArray(items,process,callback)&#123; var todo = item.concat(); setTimeout(function()&#123; var start = +new Date(); do&#123; process(todo.shift()); &#125;while(todo.length &gt; 0 &amp;&amp; (+new Date() - start &lt; 50)); if(todo.length &gt; 0)&#123; setTimeout(arguments.callee, 25); &#125;else&#123; callback(items); &#125; &#125;,25)&#125; 5.使用Web Worker：它引入了一个接口，能使代码运行且不占用浏览器UI线程的时间。一个Worker由如下部分组成：1.一个navigator对象，包括appName,appVersion,user Agent和platform.2.一个location对象，只读。3.一个self对象，指向全局worker对象4.一个importScripts()方法，用来加载worker所用到的外部js文件5.所有的ECMAScript对象。如object,Array,Date等6.XMLHttpRequest构造器7.setTimeout()，setInterval()8.一个close()方法，它能立刻停止worker运行 应用场景1.编码/解码大字符串2.复杂数学运算（包括图像，视屏处理）3.大数组排序 1234567891011121314151617// worker.jsvar worker = new Worker('code.js');// 接收信息worker.onmessage = function(event)&#123; console.log(event.data);&#125;// 发送数据worker.postMessage('hello');// code.js// 导入其他计算代码importScripts('a.js','b.js');self.onmessage = function(event)&#123; self.postMessage('hello' + event.data);&#125; 7.ajax优化 1.向服务器请求数据的五种方式：1.XMLHttpRequest2.Dynamic script tag insertion 动态脚本注入3.iframes4.Comet（基于http长连接的服务端推送技术）5.Multipart XHR（允许客户端只用一个http请求就可以从服务器向客户端传送多个资源） 2.单纯向服务端发送数据（beacons方法）——信标 123456789101112131415// 唯一缺点是接收到的响应类型是有限的var url = '/req.php';var params = ['step=2','time=123'];(new Image()).src = url + '?' + params.join('&amp;');// 如果向监听服务端发送回的数据，可以在onload中实现var beacon = new Image();beacon.src = ...;beacon.onload = function()&#123; ...&#125;beacon.onerror = function()&#123; ...&#125; 3.ajax性能的一些建议1.缓存数据 1.在服务端设置Expires头信息确保浏览器缓存多久响应（必须GET请求） 2.客户端把获取到的信息缓存到本地，避免再次请求 8.编程实践 1.避免重复工作 12345678910111213// 1.延迟加载var a = (x,y) =&gt;&#123; if(x &gt; 4)&#123; a = 0; &#125;else&#123; a = 1; &#125;&#125;// 需要使用时调用a();// 2.条件预加载（适用于函数马上执行并频繁操作的场景）var b = a &gt; 0 ? '4' : '0'; 2.使用Object/Array字面量3.多用原生方法 9.构建与部署高性能的js应用 1.js的http压缩当web浏览器请求一个资源时，它通常会发送一个Accept-Encoding HTTP头来告诉Web服务器它支持那种编码转换类型。这个信息主要用来压缩文档以获取更快的下载，从而改善用户体验。Accept-Encoding可用的值包括：gzip,compress,deflate,identity.如果Web服务器在请求中看到这些信息头，他会选择最合适的编码方式，并通过Content-Encoding HTTP头通知WEB浏览器它的决定。2.使用H5离线缓存3.使用内容分发网络CDN4.对页面进行性能分析 123456789101112131415// 检测代码运行时间var Timer = &#123; _data: &#123;&#125;, start: function(key)&#123; Timer._data[key] = new Date(); &#125;, stop: function(key)&#123; var time = Timer._data[key]; if(time)&#123; Timer._data[key] = new Date() - time; &#125;; console.log(Timer._data[key]); return Timer._data[key] &#125;&#125;; 10.浏览器缓存 1.添加Expires头2.使用cache-controlcache-ontrol详解浏览器缓存机制 11.压缩组件 1.web客户端可以通过http请求中的Accept-Encoding头来表示对压缩的支持 1234// 浏览器请求时对http header设置Accept-Encoding: gzip// Web服务器响应时对http header设置Content-Encoding: gzip 2.压缩能将响应的数据量减少将近70%，因此可考虑对html,脚本，样式，图片进行压缩 12.白屏现象的原因 浏览器（如IE）在样式表没有完全下载完成之前不会呈现页面，导致页面白屏。如果样式表放在页面底部，那么浏览器会花费更长的时间下载样式表，因此会出现白屏，所以最好把样式表放在head内。白屏是浏览器对“无样式闪烁”的修缮。如果浏览器不采用“白屏”机制，将页面内容逐步显示（如Firefox），则后加载的样式表将导致页面重绘重排，将会承担页面闪烁的风险。 13.css表达式使用一次性表达式(但最好避免css表达式) 使用css表达式时执行函数重写自身 12345678// cssp&#123; background-color: expression(altBgcolor(this))&#125;// jsfunction altBgcolor(el)&#123; el.style.backgroundColor = (new Date()).getHours() % 2 ? "#fff" : "#06c";&#125; 14.减少DNS查找 1.DNS缓存和TTL 123451.DNS查找可以被缓存起来以提高性能：DNS信息会留在操作系统的DNS缓存中（Microsoft Windows上的“DNS Client服务”,之后对该主机名的请求无需进行过多的查找2.TTL(time to live): 该值告诉客户端可以对记录缓存多久。建议将TTL值设置为一天// 客户端收到DNS记录的平均TTL只有最大TTL值的一半因为DNS解析器返回的时间是其记录的TTL的剩余时间，对于给定的主机名，每次执行DNS查找时接收的TTL值都会变化3.通过使用Keep-Alive和较少的域名来减少DNS查找4.一般建议将页面组件分别放到至少2个，但不要超过4个主机名下 15.避免重定向]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB学习指南]]></title>
    <url>%2F2018%2F03%2F30%2FmongoDB%2F</url>
    <content type="text"><![CDATA[Mongodb是分布式文档存储数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个高性能，开源，无模式的文档型数据库，是当前NoSql数据库中比较热门的一种。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式,接下来就让我们学习一下它吧! 安装和配置 mongoDB安装教程 1.基本操作 12345678910111213141516# 启动数据库服务（--dbpath后的路径代表指定数据库的路径）mongod --dbpath c:\mongoDB\data\db# 连接数据库mongo# 查看数据库show dbs# 切换/创建数据库use [数据库名]# 删除数据库1.先切换到想要删除的数据库2.执行命令: db.dropDatabase()# 创建集合并插入数据 如果集合不存在mongoDB会自动创建并插入文档db.class_name.insert(&#123;name:"一班"&#125;)# 删除集合db.collection_name.drop() 2.查询 1234567891011121314151617# 查找集合中的文档db.collection_name.find()# 以易读的方式查看查询的文档db.collection_name.find().pretty()# 除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。# MongoDB 的 find() 方法可以传入多个键(key),类似于sql的anddb.collection_name.find(&#123;key: 1, name:"xx"&#125;)# 或条件查询,类似于sql的ordb.col.find(&#123;$or:[&#123;"by":"菜鸟教程"&#125;,&#123;"title": "MongoDB 教程"&#125;]&#125;)# AND 和 OR 联合使用db.col.find(&#123;"likes": &#123;$gt:50&#125;, $or: [&#123;"by": "Mongodb中文网"&#125;,&#123;"title": "MongoDB 教程"&#125;]&#125;)# 条件操作符 -- $gt 大于; $gte 大于等于; $lt 小于; $lte 小于等于; 使用如下:db.col.find(&#123;num: &#123;$gt: 100&#125;&#125;) # 查询num值大于100的数据 3.更新修改和删除集合中的文档 123456789101112131415# 更新集合中的数据db.collection_name.update(&#123;更新前的数据&#125;,&#123;更新后的数据&#125;)# 列如:db.user.update(&#123;x:1&#125;,&#123;x:99&#125;)# 如果某一条数据有多个字段,则为了避免不覆盖,应该使用$set,其为部分操作符,$set后存在的字段将被更新,不存在的不会更新,如:db.user.update(&#123;z:1&#125;,&#123;$set:&#123;y:22&#125;&#125;)# 如果更新的数据不存在,则插入一条新数据,需要用到update第三个参数,设为truedb.user.update(&#123;z:003&#125;,&#123;y:33&#125;,true)# update默认值只更新找到的第一条数据,如果要求更新所有查询到的数据,则要使用$set和将第四个参数设为true.如:db.user.update(&#123;x:"xx"&#125;,&#123;$set:&#123;x:"xdf"&#125;&#125;,false,true)# 删除数据 remove(&#123;&#125;)内的参数必填,默认删除所有找到的数据db.user.remove(&#123;x:"22"&#125;) # 删除找到的所有x:22的数据db.user.remove(&#123;&#125;) # 删除集合中所有数据sb.user.remove(&#123;x:22&#125;,true/1) # 删除找到的第一条数据 3.2 mongoDB修改器深入 123456789101112# $inc 可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作db.user.update(&#123;num:2&#125;,&#123;$inc:&#123;num:1&#125;&#125;) # 每次执行对num增加1,默认只对第一个匹配的执行# $set 用来指定一个键并更新键值，若键不存在并创建db.a.update(&#123;"uid" : "22","type" : "3"&#125;,&#123;$set:&#123;"size":10&#125;&#125;)db.c.update(&#123;"name":"toyota"&#125;,&#123;"$set":&#123;"size.width":7&#125;&#125;) # $set通过.语法修改内嵌文档# $unset 用来删除键. 使用时，不论对目标键使用1、0、-1或者具体的字符串等都是可以删除该目标键db.a.update(&#123;"uid" : "02","type" : "3"&#125;,&#123;$unset:&#123;"size":-1&#125;&#125;)# 数组修改器 $push--向文档的某个数组类型的键添加一个数组元素，不过滤重复的数据。添加时键存在，要求键值类型必须是数组；键不存在，则创建数组类型的键db.c.update(&#123;"name" : "toyota"&#125;,&#123;$push:&#123;"title":"t1"&#125;&#125;) 4.索引 123456789101112131415161718192021222324252627282930# 查看集合索引db.user.getIndexes()# 创建索引 --单一索引 -- 1 表示正序, -1 表示逆序db.user.ensureIndex(&#123;x:1&#125;)# 过期索引--一段时间后会过期的索引,索引过期后数据也会被清除# 过期索引的限制:过期索引字段的值必须是指定的时间类型,即IOSDate或IOS数组,不能是时间戳# 如果指定了时间数组,则按最小的时间进行删除# 过期索引不能是复合索引# 过期索引是不精确的db.user.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:10&#125;)# 全文索引 --索引字段"text"为必填字段 -- 一个集合只能有一个全文索引db.user.ensureIndex(&#123;name:"text"&#125;) #对单一字段创建全文索引db.user.ensureIndex(&#123;"$**":"text"&#125;) #对集合中所有字段创建全文索引# 使用方式:db.user.find(&#123;$text:&#123;$search:"aa bb"&#125;&#125;) #在集合中查询有aa或bb字段的数据文档db.user.find(&#123;$text:&#123;$search:"aa -cc"&#125;&#125;) #在集合中查询有aa字段但不包含cc字段的文档db.user.find(&#123;$text:&#123;$search:"\"aa\" \"bb\""&#125;&#125;) #在集合中查询有aa并且有bb字段的文档# 全文索引相似度 -- &#123;score:&#123;$meta:"textScore"&#125;&#125; db.user.find(&#123;$text:&#123;$search:"aa"&#125;&#125;,&#123;score:&#123;$meta:"textScore"&#125;&#125;).sort(&#123;score:&#123;$meta:"textScore"&#125;&#125;) # 显示相似度并根据相似度排序# 全文索引的限制1.每次查询只能指定一个$text2.$text查询不能出现在$nor查询中3.目前不支持中文4.查询中如果包含$text,则hint将不再起作用]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用工具函数汇总]]></title>
    <url>%2F2018%2F03%2F18%2Fjs-tools%2F</url>
    <content type="text"><![CDATA[下面给大家梳理了我平时在工作中常用的js方法，本来是打算作为自己的工具库的，为了发现代码的最佳方案，再此贴出，望相互交流。 程序员必读 Css3编码技巧 1.检测平台（设备）类型12345var isWechat = /micromessenger/i.test(navigator.userAgent), isWeibo = /weibo/i.test(navigator.userAgent), isQQ = /qq\//i.test(navigator.userAgent), isIOS = /(iphone|ipod|ipad|ios)/i.test(navigator.userAgent), isAndroid = /android/i.test(navigator.userAgent); 2.时间格式化12345678910111213// 时间格式化function format_date(timeStamp) &#123; var date = new Date(timeStamp); return date.getFullYear() + "年" + prefix_zero(date.getMonth() + 1) + "月" + prefix_zero(date.getDate()) + "日 " + prefix_zero(date.getHours()) + ":" + prefix_zero(date.getMinutes());&#125;// 数字格式化function prefix_zero(num) &#123; return num &gt;= 10 ? num : "0" + num;&#125; 3.倒计时函数123456789101112131415// 倒计时时间格式化function format_time(timeStamp) &#123; var day = Math.floor(timeStamp / (24 * 3600 * 1000)); var leave1 = timeStamp % (24 * 3600 * 1000); var hours = Math.floor(leave1 / (3600 * 1000)); var leave2 = leave1 % (3600 * 1000); var minutes = Math.floor(leave2 / (60 * 1000)); var leave3 = leave2 % (60 * 1000); var seconds = Math.floor(leave3 / 1000); if (day) return day + "天" + hours + "小时" + minutes + "分"; if (hours) return hours + "小时" + minutes + "分" + seconds + "秒"; if (minutes) return minutes + "分" + seconds + "秒"; if (seconds) return seconds + "秒"; return "时间到！";&#125; 4.判断设备是否支持触摸事件1var isSupportTouch = ("ontouchstart" in document.documentElement) ? true : false; 5.js+rem实现移动端适配123456789101112131415161718192021222324252627(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; var fontSize = 20; docEl.style.fontSize = fontSize + 'px'; var docStyles = getComputedStyle(docEl); var realFontSize = parseFloat(docStyles.fontSize); var scale = realFontSize / fontSize; console.log("realFontSize: " + realFontSize + ", scale: " + scale); fontSize = clientWidth / 667 * 20; if(isIphoneX()) fontSize = 19; fontSize = fontSize / scale; docEl.style.fontSize = fontSize + 'px'; &#125;; // Abort if browser does not support addEventListener if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); // iphoneX判断 function isIphoneX()&#123; return /iphone/gi.test(navigator.userAgent) &amp;&amp; (screen.height == 812 &amp;&amp; screen.width == 375) &#125;&#125;)(document, window); 6.检查是否为中文1let isCN = (str) =&gt; &#123; return /^[\u4e00-\u9fa5]*$/.test(str) &#125; 7.禁用enter表单自动提交1234567891011121314151617181920212223//禁用Enter键表单自动提交 document.onkeydown = function(event) &#123; var target, code, tag; if (!event) &#123; event = window.event; //针对ie浏览器 target = event.srcElement; code = event.keyCode; if (code == 13) &#123; tag = target.tagName; if (tag == "TEXTAREA") &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; else &#123; target = event.target; //针对遵循w3c标准的浏览器，如Firefox code = event.keyCode; if (code == 13) &#123; tag = target.tagName; if (tag == "INPUT") &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125; &#125;;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css2.0深入探究]]></title>
    <url>%2F2018%2F03%2F17%2Fcss2-01%2F</url>
    <content type="text"><![CDATA[要想深入一个事物，最好对其总体有个大体的了解。要想学好css,最好对其进行深入的研究，让自己对其有足够的控制感，这样才能发挥css最大的价值。 程序员必读 Css3编码技巧 1.css尺寸1.首选最小宽度–实现复杂图形效果 在css中，图片和文字的权重远大于布局，因此当width:0时表现出来的宽度就是“首选最小宽度”。中文的最小宽度为每个汉字的宽度，西方文字取决于连续的英文字符单元。 .win-wrap{ text-align: center; } .minW{ display: inline-block; width: 0; line-height: 1.4; } .minW::before{ content: "love 你 love"; color: transparent; outline: 2px solid #cd0000; } .minW:hover::before{ content: "你 love 我"; color: transparent; outline: 2px solid #cd0000; } 123456789.minW&#123; display: inline-block; width: 0&#125;.minW:hover::before&#123; content: "你 love 我"; color: transparent; outline: 2px solid #cd0000;&#125; 2.子元素宽度设为100%时的奇怪现象原理探究 父元素的宽度 = 图片宽度 + 文字内容宽度浏览器渲染原理：先下载文档内容，加载头部样式资源，然后按从上到下、自外而内的顺序渲染dom内容。本例的现象产生的原因就是：当渲染到父元素时，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素的宽度已经固定，此时的width:100%就是以固定好的父元素的宽度，宽度不够只能溢出。 .box{ margin-left: 50%; transform: translateX(-50%); display: inline-block; height: 100px; white-space: nowrap; background-color: rgba(0,0,0,.4); } .img{ display: inline-block; width: 120px; text-align: center; } .text{ display: inline-block; width: 100%; color: #fff; background-color: #06c; } img 半透明背景色是父级width:100% 12345678.box&#123; display: inline-block; white-space: nowrap;&#125; .text&#123; display: inline-block; width: 100%;&#125; 3.如何让元素支持height:100%效果* 1.设置显示的高度值 * 2.使用绝对定位 知识点：绝对定位的宽高百分比是基于padding-box的，而非绝对定位的宽高百分比是基于content-box 4.任意高度元素的展开收起动画(max-height/min-height)* 1.min-height/min-width的初始尺寸为auto, max-height/max-width的初始尺寸为none * 2.min-height/min-width的优先级高于max-width/max-height .navbar{ width: 200px; margin: 20px auto; text-align: center; } .nav{ border-bottom: 2px solid #06c; cursor: pointer; } .nav > .sub-nav{ max-height: 0; overflow: hidden; transition: max-height .6s cubic-bezier(.17,.67,.76,1.41) } .nav:hover > .sub-nav{ max-height: 400px; } .sub-nav > div:hover{ color: #fff; background: #06c; } 首页 花朵 云彩 DIV 12345678.nav &gt; .sub-nav&#123; max-height: 0; overflow: hidden; transition: max-height .6s cubic-bezier(.17,.67,.76,1.41)&#125;.nav:hover &gt; .sub-nav&#123; max-height: 400px;&#125; 5.内联元素深入探究 常见的内联元素有：display设置为inline,inline-block,inline-table的元素内联盒模型: 1. 内容区域：可以理解为文本选中的背景色区域(重点) 2. 内联盒子：内联标签或者纯文本 3. 行框盒子：由内联盒子组成的一行，每一行就是一个行框盒子 4. 包含盒子：由行框盒子组成的盒子 幽灵空白节点：在HTML5文档声明中，内联元素的解析和渲染表现就像每个行框盒子的前面有一个空白节点一样。如下案例所示： .in-ex{ background: #06c; } 1&lt;div class="in-ex"&gt;&lt;span style="display: inline-block"&gt;&lt;/span&gt;&lt;/div&gt; 6.深入理解content 1.在web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包含边框）为300*150，如video,iframe,canvas等，少数为0，如img,而表单元素的替换尺寸和浏览器自身有关。 2.对于img元素，如果有css尺寸，则最终尺寸由css尺寸决定(css尺寸 &gt; html尺寸 &gt; 固有尺寸) 3.当图片的src属性缺省时，图片不会有任何请求，是最高效的实现方式，如下展示的是使用此方式的图片占位代码(对于firefox浏览器，src缺省的img是一个普通的内联元素，宽高设置无效)： 12img &#123; visibility: hidden; &#125;img[src] &#123; visibility: visible; &#125; 4.content内容生成技术 12345/* 1.实现换行 */::after&#123; content: '\A'; white-space: pre;&#125; 2.实现正在加载动画 .dot{ display: inline-block; width: 8em; height: 1em; line-height: 1; text-align: left; vertical-align: -.25em; overflow: hidden; } .dot::after{ display: block; margin-left: 5.2em; content: '...\A..\A.'; white-space: pre-wrap; animation: dot 3s infinite step-start both; } @keyframes dot{ 33% { transform: translateY(-3em);} 66% { transform: translateY(-2em);} 99% { transform: translateY(-1em);} } 正在加载中 123456789101112131415161718192021.dot&#123; display: inline-block; width: 8em; height: 1em; line-height: 1; text-align: left; vertical-align: -.25em; overflow: hidden;&#125;.dot::after&#123; display: block; margin-left: 5.2em; content: '...\A..\A.'; white-space: pre-wrap; animation: dot 3s infinite step-start both;&#125;@keyframes dot&#123; 33% &#123; transform: translateY(-3em);&#125; 66% &#123; transform: translateY(-2em);&#125; 99% &#123; transform: translateY(-1em);&#125;&#125; 3.属性值内容生成 .icon{ display: inline-block; padding: 2px 4px; border-radius: 4px; background: #000; } .icon::after{ content: attr(data-tip); } 12345&lt;div class="icon" data-tip="江小白"&gt;&lt;/div&gt;/* 可以使用原生属性和自定义属性 */.icon::after&#123; content: attr(data-tip);&#125; 4.计数器属性---纯css实现技术器效果 &gt; 知识点： content的计数器属性 .counter{ height: 100px; background: #06c; color: #fff; } .box1{ padding: 10px; counter-reset: count1; } .xigua:checked::before{ content: counter(count1); counter-increment: count1; position: absolute; color: transparent; } .box1::after{ content: counter(count1); position: absolute; margin-top: -100px; margin-left: 6em; transform: translateY(20px); border-radius: 50%; line-height: 60px; text-align: center; padding: 2px; width: 60px; height: 60px; box-sizing: border-box; color: #06c; background-color: #fff; } 西瓜 香蕉 萝卜 1234567891011121314151617181920.box1&#123; counter-reset: count1;&#125;.xigua:checked::before&#123; content: counter(count1); counter-increment: count1; position: absolute; color: transparent;&#125;.box1::after&#123; content: counter(count1);&#125;&lt;/style&gt;&lt;div class="counter"&gt; &lt;div class="box1"&gt; &lt;div&gt;西瓜&lt;input class="xigua" type="checkbox" /&gt;&lt;/div&gt; &lt;div&gt;香蕉&lt;input class="xigua" type="checkbox" /&gt;&lt;/div&gt; &lt;div&gt;萝卜&lt;input class="xigua" type="checkbox" /&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 6.padding深入研究1.对于盒模型设置为box-sizing: border-box的元素，如果padding足够大，那么width将失效: .pd-1{ margin-left: auto; margin-right: auto; background: #06c; width: 200px; padding-left: 120px; padding-right: 120px; box-sizing: border-box; color: #fff; } 内容为首选最小宽度 1234width: 200px;padding-left: 120px;padding-right: 120px;box-sizing: border-box; 2.对于内联元素，padding对视觉层和布局层都会有影响，如果父元素设置overflow:auto,则内联子元素的垂直padding可能会使父元素出现滚动条，否则如果父元素不设置设置overflow，只会在垂直方向上发生重叠，不会影响布局: .pd-2-1{ margin-left: auto; margin-right: auto; margin-bottom: 30px; background: #06c; width: 200px; box-sizing: border-box; color: #fff; } .pd-2-1 > span{ padding-top: 1em; padding-bottom: 1em; background: #f06; } .pd-2-2{ margin-left: auto; margin-right: auto; background: #06c; width: 200px; overflow: auto; box-sizing: border-box; color: #fff; } .pd-2-2 > span{ padding-top: 2em; padding-bottom: 2em; background: #f06; } 父元素不设置overflow 父元素设置overflow 12345678/* 父元素设置 */.pd-2-1&#123; overflow: auto;&#125;.pd-2-1 &gt; span&#123; padding-top: 1em; padding-bottom: 1em;&#125; 3.padding的实际应用（具体实现可自行思考） 1.增加链接或按钮的点击区域的大小 2.利用内联元素的padding实现高度可控的分割线 3.用内联元素实现瞄点定位距离 4.利用padding百分比值实现等比例缩放图片效果 .pd-3{ padding: 10% 50%; position: relative; } .pd-3 img{ position: absolute; width: 100%; height: 100%; left: 0; top: 0; } 1234567891011.pd-3&#123; padding: 10% 50%; position: relative;&#125;.pd-3 img&#123; position: absolute; width: 100%; height: 100%; left: 0; top: 0;&#125; ** 注：内联元素的垂直padding会让幽灵空白节点显现,此时可考虑设置font-size:0 5.padding与图形绘制 1.菜单图标设计 .icon-menu{ display: inline-block; margin-left: 10%; width: 120px; height: 10px; padding: 35px 0; border-bottom: 10px solid; border-top: 10px solid; background-clip: content-box; background-color: currentColor; } 2.双层圆点效果 .icon-dot{ display: inline-block; margin-left: 10%; width: 60px; height: 60px; padding: 10px; border-radius: 50%; border: 10px solid; background-clip: content-box; background-color: currentColor; } 12345678910111213141516171819202122 /* 菜单 */ .icon-menu&#123; display: inline-block; width: 120px; height: 10px; padding: 35px 0; border-bottom: 10px solid; border-top: 10px solid; background-clip: content-box; background-color: currentColor;&#125;/* 双层圆点 */.icon-dot&#123; display: inline-block; width: 60px; height: 60px; padding: 10px; border-radius: 50%; border: 10px solid; background-clip: content-box; background-color: currentColor;&#125; 7.margin深入研究 1.使用:nth-type-of(3n)去除子元素尾部margin .mg-wrap{ width: 640px; height: 100px; background: #000; } .mg-item{ float: left; width: 200px; height: 100px; background: #06c; color: #fff; text-align: center; margin-right: 20px; } .mg-item:nth-of-type(3n){ margin-right: 0; } margin-right: 20px margin-right: 20px margin-right: 20px 123.mg-item:nth-of-type(3n)&#123; margin-right: 0;&#125; 注：如果容器可以滚动，在IE和firefox下会忽略padding-bottom的值，chrome则不会，此时可以通过margin-bottom实现滚动容器的底部留白 .box-wrap{ width: 640px; height: 100px; padding: 30px 0; overflow: auto; background: #000; } .box-inner{ width: 200px; height: 200px; background: #06c; } * 其本质区别在于：chrome是子元素超过父元素content box尺寸触发滚动条显示，而IE和Firefox浏览器是超过padding box尺寸时触发滚动条显示 2.margin合并块级元素，但不包含浮动和绝对定位元素在默认文档流下只出现在垂直方向 margin合并的三种场景 1.相邻兄弟元素 2.父级和第一个/最后一个子元素* 解决方案： 父级设置为块级格式化上下文元素 父元素设置border-top/bottom值 父元素设置padding-top/bottom值 父元素设置高度 3.空块级元素margin合并 margin合并的计算规则 “正正取大值”，”正负值相加”，”负负最负值” 深入理解margin:auto 1.如果一侧定值，一侧auto，则auto为剩余空间大小 2.如果两侧均是auto，则平分剩余空间 3.触发margin:auto计算的前提：width或height为auto时，元素是具有自动填充特性的。 .father{ position: relative; margin: 20px; height: 60px; overflow: auto; background: #000; } .child-1{ width: 40px; height: 20px; background: #06c; margin-right: 20px; margin-left: auto; } .child-2{ position: absolute; left: 0; bottom: 0; right: 0; top: 0; width: 40px; height: 20px; background: #06c; margin: auto; } 123456/* 1 */margin-right: 20px;margin-left: auto;/* 2 */margin-right:auto;margin-left: auto; 绝对定位元素利用margin:auto实现水平垂直居中(兼容到ie8+) 12345678910.father&#123; position: relative;&#125;.child-2&#123; position: absolute; left: 0; bottom: 0; right: 0; top: 0; width: 40px; height: 20px; margin: auto;&#125; margin无效情形解析 display计算值为inline的非替换元素的垂直margin是无效的 对于内联替换元素，垂直margin有效，并且没有margin合并问题，所以永远不会发生margin合并 内联特性导致margin失效：一个容器里面有一个图片，图片设置margin-top,随着margin-top负值越来越大，达到某一具体负值时，图片将不再往上偏移 8.border深入研究 重置边框的高性能方案 border-width的默认值为3px,边框宽度没有半像素的概念边框样式的默认值是none,经测试以下方案性能最优 1234.border&#123; border: 2px solid #ccc; border-bottom: 0 none;&#125; border-style: double的高级用法 double的表现规则: 双线宽度永远相等，中间间隔+-1利用双线边框实现菜单按钮 .border-icon{ margin-left: auto; margin-right: auto; width: 100px; height: 20px; border-top: 60px double #06c; border-bottom: 20px solid #06c; transition: transform 1s; } .border-icon:hover{ transform: rotate(90deg); } 123456.border-icon&#123; width: 100px; height: 20px; border-top: 60px double #06c; border-bottom: 20px solid #06c;&#125; 9.字母x与css中的基线 基线 字母x的下边缘x-height 指字母x的高度ex：ex指小写字母x的高度，是相对单位vertical-align:middle 指的是基线往上1/2 x-height高度 .txt-wrap{ line-height: 1; } .f1{ font-size: 40px; vertical-align: middle } .f3{ font-size: 30px; vertical-align: middle } .f2{ display: inline-block; width: 10px; height: 2ex; background: #000; } X X 1内联元素设置对齐方式时，是基于最前面的内联元素的基线，然后根据自己的vertical-align来调整对齐的 10.line-height深入研究 1.对于非替换元素的纯内联元素，其可视高度完全由line-height决定，padding,border对其可视高度没有任何影响。2.line-height不能影响替换元素的高度 .lh-wrap{ margin-bottom: 20px; line-height: 1em; font-size: 30px; border: 1px solid #000; } .lh1{ border: 1px solid #000; } 徐r 3.line-height属性值的具体了解： 数值：如1.5，即1.5倍字体大小，此时子元素将继承1.5而不是最终父元素计算的值 百分比：如200%，子元素将继承最终计算的值 em：如2m，子元素将继承最终计算的值 4.多行文本垂直居中 .lh2-wrap{ margin: 20px auto; width: 400px; line-height: 7em; font-size: 16px; border: 1px solid #000; } .lh2-1{ display: inline-block; line-height: 2em; vertical-align: middle; } 徐rjhfj下客服打击开发商电话JFK幅度萨芬京东卡好的的JFK是否获得男子冒充 123456789/* 文本块用inline-block，借助vertical-align: middle */.lh2-wrap&#123; line-height: 7em;&#125;.lh2-1&#123; display: inline-block; line-height: 2em; vertical-align: middle;&#125; 5.计算行高时，一定要向上舍入，因为谷歌浏览器计算数值时是向下取整的6.无论内联元素line-height如何设置，最终父元素的高度都是由数值大的那个line-height决定的。 10.vertical-align深入探究 1.vertical-align的数值百分比属性值介绍： 数值： 如vertical-align: 10px; 正值往上偏移，负值往下偏移，兼容性良好 百分比： 如vertical-align: 10%; 基于line-height计算，不过不常用 2.vertical-align的作用前提： 只能应用于内联元素和display:table-cell的元素 注：1.浮动和绝对定位会让元素块状化，所以使用vertical-align时会失效 2.对于teble-cell元素而言，vertical-align作用的是自身，因为其本身有内联性质，所以对子元素设置vertical-align无效 3.vertical-align和line-height的关系重要 现象1：容器高度不等于行高 .lh3-wrap{ margin: 20px auto; width: 200px; background: #000; line-height: 32px; } .lh3-1{ /* display: inline-block; */ font-size: 28px; background: #06c; color: #fff; /* vertical-align: bottom; */ } x徐rjhfj下客 123456.lh3-wrap&#123; line-height: 32px;&#125;.lh3-1&#123; font-size: 28px;&#125; 为什么实际高度会超过32px呢？是因为幽灵空白节点的字体大小和内联元素字体大小不同，字体越大基线越低导致两个元素上下偏移，使得容器高度超过原先的设定。解决方案：1.内联元素设置对其方式为bottom或者top 2.将幽灵空白节点和内联元素字体设置成一样的 现象2. 图片底部始终留有间隙的问题 原因：是由line-height,vertical-align和和幽灵空白节点共同决定的。因为图片之前的空白节点和图片默认基线对齐，而幽灵空白节点的行高导致多余的间隙导致图片下面空出了一段距离。解决方案： 1.图片块状话化 2.容器line-height足够小 3.图片设置vertical-align为top,bottom,middle任意一种 现象3. 图片设置margin-top到一定值时无效原因： 被幽灵空白节点的vertical-align:baseline限定死了 4.应用-实现垂直剧中的弹窗 .mask{ position: fixed; /* z-index: 9999; */ display: none; left: 0; top: 0; right: 0; bottom: 0; text-align: center; background: rgba(0,0,0,.8); font-size: 0; white-space: nowrap; overflow: auto; } .mask::after{ content: ''; display: inline-block; height: 100%; vertical-align: middle; } .dialog{ display: inline-block; text-align: left; font-size: 14px; color: #fff; white-space: normal; } #show_mask{ display: inline-block; padding: 4px 10px; border-radius: 4px; background: #06c; color: #fff; cursor: pointer; } dddd 显示弹窗 var btn = document.getElementById("show_mask"), mask = document.getElementById("mask1"), isShow = false; btn.onclick = function(){ mask.style.display = "block"; isShow = true; } mask.onclick = function(){ this.style.display = "none"; isShow = false; } 1234567891011121314151617181920212223242526.mask&#123; position: fixed; /* z-index: 9999; */ left: 0; top: 0; right: 0; bottom: 0; text-align: center; background: rgba(0,0,0,.8); font-size: 0; white-space: nowrap; overflow: auto;&#125;.mask::after&#123; content: ''; display: inline-block; height: 100%; vertical-align: middle;&#125;.dialog&#123; display: inline-block; text-align: left; font-size: 14px; color: #fff; white-space: normal;&#125; 11.float作用机制 1.作用机制: 使父元素高度塌陷从而实现文字环绕效果 2.float的定位参考是行框盒子,位于哪个行框盒子后就与哪个行框盒子对齐 3.clear属性只有块级元素才有效,如果clear:both元素前面是float元素,则设置margin-top负值无效 4.clear:both后面的元素仍然可能发生文字环绕效果 12.BFC–块级格式化上下文 1.表现: 元素内部的布局变化不会影响外部的元素.所以不会出现margin合并,可用来清除浮动的影响. 2.触发BFC的条件: 根元素 float的值不为none overflow的值为auto,scroll,hidden display的值为table-cell,inline-block position的值不为static或者relative 3.若元素具备BFC特性,则无需clear:both去清除浮动 4.display:table-cell的特性: 宽度设置的再大,也不会超过表格容器的宽度 5.overflow裁切界限:border box: 一个设置了overflow: hidden的元素同时设置了padding和border,则子元素超出容器宽高设置时,裁切的边界是border box内边缘而不是padding box内边缘 6.在PC端,默认滚动条均来自,PC端滚动高度可以用document.documentElement.scrollTop获取,在移动端用document.body.scrollTop获取 7.PC端滚动条宽度约为17px 8.让页面滚动条不出现晃动的方法: 123456789101112131415html&#123; /* ie8 */ overflow-y: scroll;&#125;:root&#123; overflow-y: auto; overflow-x: hidden;&#125;:root body&#123; position: absolute;&#125;body&#123; width: 100vw; overflow: hidden;&#125; 9.多行文本溢出显示省略号的css方法: 12345.ell-rows-2&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2;&#125; 13.overflow与position:absolute 1.如果overflow不是定位元素,并且绝对定位元素和overflow容器之间没有定位元素,则overflow无法对absolute元素进行切割2.如果overflow属性值不是hidden而是auto或者scroll,则即使绝对定位元素宽高溢出也不会出现滚动条3.对于现代浏览器,如果overflow子元素transform溢出,则会裁剪’’4.overflow默认值为visible,内容不会被修剪，会呈现在元素框之外 14.absolute与clip 1.clip属性要想起作用，元素必须是absolute或者fixed,语法如下： 12/* 裁剪区域，不支持缩写和百分比值 */clip: rect(top right bottom left) 2.clip应用与渲染 1.最佳可访问性隐藏 12345/* 多用于SEO优化和对表单控件样式的优化以及屏幕阅读器的可访问性 */.clip&#123; position: absolute; clip: rect(0 0 0 0);&#125; 2.clip渲染 clip隐藏仅仅决定了哪部分是可见的，对于原来占据的空间并没有影响，非可见部分无法响应点击事件。在ie和火狐浏览器中，抹掉了不可见区域尺寸对布局的影响，chorme浏览器却保留了。 .re-box{ position: relative; width: 200px; height: 200px; background: #eee; overflow: auto; } .sb-sub{ position: absolute; width: 180px; height: 280px; clip: rect(0 0 0 0); } document.querySelector(".sb-sub").onclick = function(){ alert(1) } 12345678910111213.re-box&#123; position: relative; width: 200px; height: 200px; background: #eee; overflow: auto;&#125;.sb-sub&#123; position: absolute; width: 180px; height: 280px; clip: rect(0 0 0 0);&#125; absolute流体特性 1.absolute流体特性产生的前提： 对立方向上同时发生定位的时候 .re{ position: relative; margin-left: 10%; width: 300px; height: 300px; background: #000; } .ab{ position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin-right: 20px; margin-left: auto; background: #06c; } 123456789/* 此时设置padding和margin，其占据的空间将不变，变化的是content box的尺寸 */.ab&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: 20px;&#125; 2.absolute的margin:auto居中 .re{ position: relative; margin-left: 10%; width: 300px; height: 300px; background: #000; } .ab1{ position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 200px; height: 200px; margin: auto; background: #06c; } 12345678/* 绝对定位元素的margin:auto的填充规则和普通流体一样如果一侧定值一侧auto,auto未剩余空间大小 */.ab1&#123; position: absolute; left: 0;right: 0;top: 0;bottom: 0; width: 200px; height: 200px; margin: auto;&#125; 3.在有些场合下，百分比transform会让ios微信闪退，尽量避免用其使元素居中，可以采用absolute和margin:auto解决 15.relative难点解析 1.relative的定位位移是相对于自身的，如果left/top/right/bottom的值为百分比单位，则计算尺寸是基于父元素 2.如果left/right 或top/bottom这些对立属性同时出现时，只有一个方向的属性会生效，优先级与文档流的顺序有关，默认的文档流是自上而下，从左到右的，所以top优先级高于bottom,left优先级高于right 3.relative的最小化原则 1.尽量不使用relative,可以采用无依赖绝对定位解决某些问题2.如果一定要使用relative,则relative务必最小化（最小包含区域） –为了避免层级覆盖等问题 4.层叠上下文 1.定位元素的默认z-index:auto;此时和普通元素一样，一旦z-index设置为任意数值，就创建了一个层叠上下文，顺序为：层叠上下文 &lt; 负z-index &lt; block &lt; float &lt; inline &lt; z-index:auto &lt; 正z-index2.css3新属性的层叠上下文：1.flex2.opacity不为13.transform不为none4.mix-blend-mode不为normal5.filter不为none6.isolation是isolate7.will-change为上面2-6的任意一个8.元素-webkit-overflow-scrolling设为touch 3.z-index负值在block下面，实际应用： 1.可访问性隐藏 2.ie8下的多背景隐藏 16.字体相关 1.font-weight数值 font-weight的数值范围是100-900，值必须是整百 2.text-indent text-indent:100% 百分比值是基于当前元素的包含块计算的，即父元素宽度 3.text-indent应用–对话式排版 .t-in{ width: 80%; margin-left: 20%; } .t{ text-indent: -2em; border-bottom: 1px solid #eee; } .t:first-letter{ color: #06f; } 明：我其实一开始就知道，我喜欢你，所以，让我追你吧，用尽一切力量，守护你，呵护你，或许自己还不够成熟？是吗？那就试试看，好不好！ 红：我其实一开始就知道，我喜欢你，所以，让我追你吧，用尽一切力量，守护你，呵护你，或许自己还不够成熟？是吗？那就试试看，好不好！ 1text-indent: -2em; 4.letter-spacing 用来控制字符之间的变化，包括英文字母，汉字以及空格 其负值只能让字符重叠，不能让替换元素，inline-table发生重叠word-spacing是单词间距 5.按钮之间的间距可以用如下方法设置 123.btn + .btn&#123; margin-left: 20px;&#125; 6.强制换行 word-break: break-all 所有字符只要超出就换行，而word-break: break-word会保留整个单词的完整性 7.实现中文两端对齐兼容方案 1234.justify&#123; text-align: justify; text-justify: inter-ideograph;&#125; 8.字符串大小写text-transform 身份证输入等强制大写 123input&#123; text-transform: uppercase;&#125; 9.::first-letter–作用于子元素 应用：实现字体控制 .t-tr{ font-size: 28px; text-indent: 2em; } .t-tr:first-letter{ font-size: 36px; color: red; } ￥200 12345.t-tr:first-letter&#123; font-size: 36px;&#125;&lt;/style&gt;&lt;div class="t-tr"&gt;￥200&lt;/div&gt; 10.隐藏元素的background-image的加载 在firfox下，display:none的元素的background-image不加载，包括父元素设置display: none,在chrome和safari下若父元素为display:none则不加载，本身隐藏会加载，对于ie来说都会加载通过背景图片实现鼠标经过切换图片效果时最好把两张图片合成一张图，这样既减少请求又可以提高用户体验 11.background-position百分比计算规则 positionX = (容器宽度 - 图片宽度) percentXpositionY = (容器高度 - 图片高度) percentY 12.兼容PC端的hidden属性 1234[hidden]&#123; display: none;&#125;&lt;div hidden&gt;&lt;/div&gt; 13.visibility的继承性 父元素设置visibility: hidden,子元素会继承该特性，如果子元素设置visibility: visible,则子元素会显示出来visibility: hidden不会影响计数器技术，而display：none会影响有过渡效果，display则没有 14.user-select:none使得文本不能选中 123user-select: none;/* 默认鼠标图形 */cursor: default; 15.自定义光标 123.cur&#123; cursor: url(transparent.cur);&#125;]]></content>
      <categories>
        <category>css2高级</category>
      </categories>
      <tags>
        <tag>css2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过渡与动画]]></title>
    <url>%2F2018%2F03%2F15%2Fanimation-transition%2F</url>
    <content type="text"><![CDATA[网页中过渡与动画是一种流行的表现手法，可以让界面显得更加生动和真实，接下来我们介绍的css3新特性，可以让你的web变得更加富有动感，让我们来看看精彩的案例吧！ 程序员必读 Css3编码技巧 1.弹性过渡–纯css实现表单提示层效果 知识点：贝塞尔曲线在线工具 .control{ width: 400px; margin: 20px auto; } .tip{ position: absolute; margin-left: -200px; margin-top: 36px; padding: 2px 6px; font-size: 12px; color: #fff; border-radius: 4px; border: 1px solid #ccc; background: #06c; transform-origin: 0 0; transition: transform .5s cubic-bezier(.25,.1,.3,1.5); } input{ width: 200px; height: 26px; } input:not(:focus) + .tip{ transform: scale(0); transition: transform ease .25s; } 用户名 请输入用户名 123456789101112131415161718192021.tip&#123; position: absolute; margin-left: -200px; margin-top: 36px; padding: 2px 6px; font-size: 12px; color: #fff; border-radius: 4px; border: 1px solid #ccc; background: #06c; transform-origin: 0 0; /* 关键 */ transition: transform .5s cubic-bezier(.25,.1,.3,1.5); /* 关键 */&#125;input&#123; width: 200px; height: 26px;&#125;input:not(:focus) + .tip&#123; transform: scale(0); /* 关键 */ transition: transform ease .25s; /* 关键 */&#125; 2.逐帧动画 知识点：steps() .keyframes-wrap{ width: 128px; height: 130px; margin: 20px auto; background: url(http://p3g4ahmhh.bkt.clouddn.com/animate.jpg) no-repeat top left; animation: loader 1s infinite steps(8); text-indent: 200%; white-space: nowrap; overflow: hidden; } @keyframes loader { to { background-position: -1024px; } } 正在加载... 12345678910.keyframes-wrap&#123; background: url(http://p3g4ahmhh.bkt.clouddn.com/animate.jpg) no-repeat top left; animation: loader 1s infinite steps(8); text-indent: 200%; white-space: nowrap; overflow: hidden;&#125;@keyframes loader &#123; to &#123; background-position: -1024px; &#125;&#125; 3.利用css控制动画的暂停和播放 知识点：animation-play-state .bg-wrap{ width: 300px; height: 130px; margin: 20px auto; background: url(http://p3g4ahmhh.bkt.clouddn.com/bg.jpg); background-size: auto 100%; animation: move 5s linear infinite alternate; animation-play-state: paused; } .bg-wrap:hover,.bg-wrap:focus{ animation-play-state: running; } @keyframes move { to { background-position: 100% 0; } } 123456789101112.bg-wrap&#123; background: url(http://p3g4ahmhh.bkt.clouddn.com/bg.jpg); background-size: auto 100%; animation: move 5s linear infinite alternate; animation-play-state: paused;&#125;.bg-wrap:hover,.bg-wrap:focus&#123; animation-play-state: running;&#125;@keyframes move &#123; to &#123; background-position: 100% 0; &#125;&#125; 4.沿环形路径平移的动画 知识点：transform: rotate(1turn); transform-origin变换的源点是基于自身的尺寸,默认值为自身的中心 .box{ display: flex; align-items: center; justify-content: center; width: 200px; height: 200px; border-radius: 100%; overflow: hidden; margin: 20px auto; background: orange; } .avator{ width: 60px; height: 60px; padding: 0; margin: 0 !important; border-radius: 100%; animation: spin 5s linear infinite; } @keyframes spin { from{ transform: rotate(0turn) translateY(-100px) translateY(50%) rotate(1turn) } to{ transform: rotate(1turn) translateY(-100px) translateY(50%) rotate(0turn) } } 1234567891011121314151617/* 首先要想方法让头像在父元素中居中 */.avator&#123; animation: spin 5s linear infinite;&#125;@keyframes spin &#123; from&#123; transform: rotate(0turn) translateY(-100px) translateY(50%) rotate(1turn) &#125; to&#123; transform: rotate(1turn) translateY(-100px) translateY(50%) rotate(0turn) &#125;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>transition</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据兄弟元素数量来设置样式]]></title>
    <url>%2F2018%2F03%2F14%2Fselector%2F</url>
    <content type="text"><![CDATA[接下来我为大家介绍一种类似js效果的选择器，可以根据兄弟元素的数量来设置样式，那么我们开始吧。 程序员必读 Css3编码技巧 1. 当只有一项时的样式–only-child .list{ width: 80%; padding: 1em; margin-left: auto; margin-right: auto; margin-bottom: 20px; border-radius: 8px; color: #fff; background: #000; } .item{ display: inline-block; padding: .4em .6em; border-radius: 8px; line-height: 1em; } .item:only-child{ background: gray; } one 123.item:only-child&#123; /* 只有一个列表项时的样式 */ background: gray;&#125; 2. 根据兄弟元素的数量范围来选择元素 .item:nth-child(n+4){ background: orange; } .item-1:first-child:nth-last-child(n+4), .item-1:first-child:nth-last-child(n+4) ~ .item-1{ background: blue; } .item-2:first-child:nth-last-child(-n+4), .item-2:first-child:nth-last-child(-n+4) ~ .item-2{ background: green; } .item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6), .item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ .item-3{ background: #f6c; } 1. 选择列表中第四项及以后的所有项 one two three four five six 2. 列表至少有4项时选中所有项 one two three four five 3. 列表最多包含4项时选中所有项 one two three four 4. 列表项在2-6项时选中所有项 one two three four five six 1234567891011121314/* 1. 选择列表中第四项及以后的所有项 */.item:nth-child(n+4)/* 2. 列表至少有4项时选中所有项 */.item-1:first-child:nth-last-child(n+4),.item-1:first-child:nth-last-child(n+4) ~ .item-1/* 3. 列表最多包含4项时选中所有项 */.item-2:first-child:nth-last-child(-n+4),.item-2:first-child:nth-last-child(-n+4) ~ .item-2/* 4. 列表项在2-6项时选中所有项 */.item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6),.item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ .item-3]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>nth-child(n)</tag>
        <tag>only-child</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义单选框复选框]]></title>
    <url>%2F2018%2F03%2F14%2Fcheckbox%2F</url>
    <content type="text"><![CDATA[我们都知道原生的复选框控件样式极难自定义，这对于工程师实现设计稿的难度加大了一大截。css3的出现，增加了:checked选择器，因此我们可以利用:checked和label来实现各式各样的表单选择控件，接下来让我们来看看如何实现吧！ 程序员必读 Css3编码技巧 1.自定义复选框 .check-wrap{ text-align: center; } .checkbox{ position: absolute; clip: rect(0,0,0,0); } .checkbox[type="checkbox"]:focus + label::before{ box-shadow: 0 0 .6em #06c; } .checkbox[type="checkbox"] + label::before{ content: '\a0'; /* 不换行空格 */ display: inline-block; margin-right: .3em; width: 2em; height: 2em; border-radius: .3em; vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; background: gray; } .checkbox[type="checkbox"]:checked + label::before{ content: '\2713'; /* 对勾 */ background: black; } label{ margin-right: 40px; font-size: 20px; } 生男孩 生女孩 123456789101112131415161718192021222324.checkbox&#123; position: absolute; clip: rect(0,0,0,0);&#125;.checkbox[type="checkbox"] + label::before&#123; content: '\a0'; /* 不换行空格 */ display: inline-block; margin-right: .3em; width: 2em; height: 2em; border-radius: .3em; vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; background: gray;&#125;.checkbox[type="checkbox"]:checked + label::before&#123; content: '\2713'; /* 对勾 */ background: black;&#125; 2.自定义开关 .check-wrap{ margin-bottom: 20px; text-align: center; } .switch{ position: absolute; clip: rect(0,0,0,0); } .switch[type="checkbox"] + label{ width: 6em; height: 3em; padding: .3em; border-radius: .3em; border: 1px solid rgba(0,0,0,.2); vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; box-shadow: 0 1px white inset; background-color: #ccc; background-image: linear-gradient(#ddd,#bbb); } .switch[type="checkbox"]:checked + label{ box-shadow: 0.05em .1em .2em rgba(0,0,0,.6) inset; border-color: rgba(0,0,0,.3); background: #bbb; } label{ margin-right: 40px; font-size: 14px; } .switch-an{ position: absolute; clip: rect(0,0,0,0); } .switch-an[type="checkbox"] + label{ position: relative; display: inline-block; width: 5em; height: 2em; border-radius: 1em; color: #fff; background: #06c; text-align: left; } .switch-an[type="checkbox"] + label::before{ content: ''; width:2em; height: 2em; position: absolute; left: 0; border-radius: 100%; vertical-align: middle; background-color: #fff; transition: left .3s; } .switch-an[type="checkbox"] + label::after{ content: 'OFF'; margin-left: 2.6em; } .switch-an[type="checkbox"]:checked + label::before{ transition: left .3s; left: 3em; } .switch-an[type="checkbox"]:checked + label::after{ content: 'NO'; margin-left: .6em; } 生男孩 生女孩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* 1 */.switch&#123; position: absolute; clip: rect(0,0,0,0);&#125;.switch[type="checkbox"] + label&#123; width: 6em; height: 3em; padding: .3em; border-radius: .3em; border: 1px solid rgba(0,0,0,.2); vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; box-shadow: 0 1px white inset; background-color: #ccc; background-image: linear-gradient(#ddd,#bbb);&#125;.switch[type="checkbox"]:checked + label&#123; box-shadow: 0.05em .1em .2em rgba(0,0,0,.6) inset; border-color: rgba(0,0,0,.3); background: #bbb;&#125;/* 2 */.switch-an&#123; position: absolute; clip: rect(0,0,0,0);&#125;.switch-an[type="checkbox"] + label&#123; position: relative; display: inline-block; width: 5em; height: 2em; border-radius: 1em; color: #fff; background: #06c; text-align: left;&#125;.switch-an[type="checkbox"] + label::before&#123; content: ''; width:2em; height: 2em; position: absolute; left: 0; border-radius: 100%; vertical-align: middle; background-color: #fff; transition: left .3s;&#125;.switch-an[type="checkbox"] + label::after&#123; content: 'OFF'; margin-left: 2.6em;&#125;.switch-an[type="checkbox"]:checked + label::before&#123; transition: left .3s; left: 3em;&#125;.switch-an[type="checkbox"]:checked + label::after&#123; content: 'NO'; margin-left: .6em;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>checkbox</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-effect]]></title>
    <url>%2F2018%2F03%2F13%2Ftext-effect%2F</url>
    <content type="text"><![CDATA[文字特效在过去大部分都用图片代替，但是自从有了css3,前端的宝宝再也不用担心没有设计师来切图了。接下来就让我来给大家展示text-shadow的强大效果吧！ 程序员必读 Css3编码技巧 1.凸凹印刷效果 .effect-1{ width: 300px; margin-left: auto; margin-right: auto; line-height: 2em; background: hsl(210,13%,60%); color: hsl(210,13%,30%); text-shadow: 0 1px 1px hsla(0,0%,100%,.8); } the only way to get rid of a temptation is to yield to it. 1text-shadow: 0 1px 1px hsla(0,0%,100%,.8); 2.空心字效果 .effect-2{ width: 300px; margin-left: auto; margin-right: auto; font-size: 30px; text-align: center; line-height: 2em; background: deeppink; color: #fff; text-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000; } the only way. 1234text-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000; 3.文字外发光效果(鼠标经过文字会有惊喜哦！) .effect-3{ width: 300px; margin-left: auto; margin-right: auto; font-size: 30px; text-align: center; line-height: 2em; background: #203; color: #ffc; text-shadow: 0 0 .1em, 0 0 .3em; transition: 1s; } .effect-3:hover{ text-shadow: 0 0 .6em, 0 0 .8em; } hover me! 12text-shadow: 0 0 .1em, 0 0 .3em; 3.文字凸起效果 .effect-4{ width: 300px; margin-left: auto; margin-right: auto; font-size: 30px; text-align: center; line-height: 2em; background: #ccc; color: #fff; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px #000; transition: 1s; } .effect-4:hover{ text-shadow: 0 1px hsl(0,0%,85%); } hover me! 123456text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px #000;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>text-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用码云]]></title>
    <url>%2F2018%2F03%2F12%2Fgit-china%2F</url>
    <content type="text"><![CDATA[使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况。如果我们希望良好的体验速度，可以使用国内的Git托管服务——码云。 使用方法与步骤1.在码云上添加ssh公钥，新建一个项目2.本地库上使用命令git remote add把它和码云的远程库关联。1git remote add origin git@gitee.com:xujiang/learngit.git 之后，就可以正常地用git push和git pull推送了！ 3.如果在使用远程库时报错：1fatal: remote origin already exists. 这说明本地库已经关联了一个远程库，此时，可以先用git remote -v查看远程库信息 我们可以删除已有的GitHub远程库： 1git remote rm origin(假设远程库名叫origin) 再关联码云的远程库： 1git remote add origin git@gitee.com:xujiang/learngit.git 如果我想关联两个不同的版本库呢？ 1.首先远程库A 1git remote add A git@gitee.com:xujiang/learngit.git 2.再关联远程库B 1git remote add B git@github.com:xujiang/learngit.git 此时，如果要推送到A上，则可以： 1git push A master 要推送到B上，则可以： 1git push B master 学习链接]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git全解读]]></title>
    <url>%2F2018%2F02%2F12%2FgitStudy%2F</url>
    <content type="text"><![CDATA[版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 程序员必读 Css3编码技巧 创建并提交一个版本库 课外知识: mkdir 创建目录; pwd 显示绝对路径; cat 文件名 查看文件内容注：所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，如果要真要使用版本控制系统，就要以纯文本方式编写文件。千万不要使用Windows自带的记事本编辑任何文本文件,原因是Microsoft开发记事本的团队,在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题. 1.核心操作1234567891011# 1.初始化仓库,.git目录默认隐藏,可以通过命令ls -ah显示git init# 2.把文件添加到版本库，可以一次添加多个文件，git add . 代表把所有文件全部提交git add 文件名 文件名# 3.把文件提交到当前分支git commit -m '本次提交的说明'# 4.把项目提交到(远程)仓储git push 2.分支管理123456789101112131415161718192021# 1.查看远程分支git branch -a# 2.查看本地分支git branch# 3.创建并切换分支 （加-b表示创建并切换）git checkout -b 分支名# 4.切换回分支git checkout 分支名# 5.从主分支里创建新分支git checkout master -b 新分支名# 6.合并某分支到当前分支git merge 分支名# 7.删除分支git branch -d 分支名git branch -D 分支名 (强行删除分支) 3.解决冲突123456789101112131415# 情景一 提交或拉取时冲突git stashgit pullgit stash pop# 情景二 如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pullgit reset --hard HEAD^git pull origin master# 注：origin master表示git的主分支# 情景三 分支合并时冲突(当我们git merge 分支名 时)1.git status (查看发生冲突的文)2.然后手动合并冲突3.git add . (添加更改后的文件)4.git commit -m 'xj' (提交) 4.查看ssh密钥1234# 1.进入.ssh目录cd ~/.ssh# 2.查看id_rsa.pub文件cat id_rsa.pub 5.克隆远程项目1git clone 远程源地址 6.回退某个操作1234# 1.查看命令历史git reflog# 2.根据commitID撤销某个操作git reset --hard 某个commitId 7.和远程分支建立关联1git branch --set-upstream-to=origin/远程分支的名字 本地分支名 8.删除文件12345# 删除版本库中的文件git rm filename# 恢复工作区中误删的文件git checkout -- filename# 注：git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 9.远程仓储1234567# 1.创建sshkey密钥ssh-keygen -t rsa -C "youremail@example.com"# 2.在远程仓库中添加ssh公钥# 3.关联远程库git remote add origin git@server-name:path/repo-name.git# 4.第一次推送master分支的所有内容,此后只需要使用git push origin master即可推送最新修改git push -u origin master 10.多人协作12345678910# 1.查看远程仓储的详细信息git remote -v# 2.推送本地分支到远程仓库, #1.如果发生冲突，用git pull试图合并，如果发生冲突则解决冲突，再进行推送 #2.如果git pull后提示no tracking information(没有追踪信息)，则进行第四项，建立关联，之后pull，有冲突再合并git push origin 本地分支名# 3.在本地创建和远程分支对应的分支git checkout -b 本地分支 origin/远程分支名# 4.建立本地分支和远程分支的关联git branch --set-upstream 本地分支名 origin/远程分支名 11.分支策略1231.master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；2.干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；3.每个人都有自己的分支，时不时地往dev分支上合并就可以了 补充 123456789101112131415161718192021# 查看仓库当前的状态git status// 查看提交日志git log# 回退版本,在git中用HEAD表示当前版本,HEAD^表示上一个版本,HEAD^^表示上上个版本git reset --hard HEAD^ 或git reset --hard 3628164 (数字代表log里commit后面的id,只需要填前几位就可以)# 窗口关闭后回退版本(git reflog用来记录你的每一次命令)git reflog# 工作区和暂存区工作区就是你建立的能看见的目录,.git即为git的版本库,Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。用git add把文件添加进去，实际上就是把文件修改添加到暂存区；用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支# 撤销修改1.直接丢弃工作区的修改，用命令git checkout -- file2.修改添加到了暂存区，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3形状篇]]></title>
    <url>%2F2018%2F02%2F10%2Fshape%2F</url>
    <content type="text"><![CDATA[形状是网页中必不可少的一部分,它使得网页更加生动和精致,接下来就让我们开启css3形状之旅！ 程序员必读 Css3：box-shadow高级应用 .black-theme{ margin-left: auto; margin-right: auto; margin-bottom: 20px; text-align: center; border-radius: 8px; background-color: #000; color: #fff; } 1.制做平行四边形/棱形/梯形 知识点: transform: skew(deg),&nbsp;&nbsp;//skew代表斜切,值为角度 transform-origin: bottom/left/top(默认)/right 变换源点的位置 .sp-1{ position: relative; width: 140px; height: 80px; line-height: 80px; color: #fff; text-align: center; background-color: transparent; } .sp-1::before{ content: ''; position: absolute; z-index: -1; left: 0; right: 0; bottom: 0; top: 0; background-color: #06c; transform: skew(45deg); } .sp-1-1::before{ transform: scaleY(2) perspective(.5em) rotateX(5deg); transform-origin: bottom; } 平行四边形 梯形 核心代码 123456789101112131415/* 对伪类添加变形 */.sp-1::before&#123; content: ''; position: absolute; z-index: -1; left: 0; right: 0; bottom: 0; top: 0; background-color: #06c; transform: skew(45deg);&#125;/* 梯形 */transform: scaleY(2) perspective(.5em) rotateX(5deg);transform-origin: bottom; 2.制做切角效果 知识点: 利用背景渐变 .sp-2, .sp-3{ width: 140px; height: 80px; line-height: 80px; color: #fff; text-align: center; border-radius: 0; } .sp-2{ background: linear-gradient(-135deg,transparent 12px,#06c 0); } .sp-3{ background: radial-gradient(circle at top left,transparent 12px,#06c 0) no-repeat 0 0; } 切角 圆形切角 核心代码 1234/* 正切角 */background: linear-gradient(-135deg,transparent 12px,#06c 0);/* 圆形切角 */background: radial-gradient(circle at top left,transparent 12px,#06c 0) no-repeat 0 0;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>border-radius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border——radius篇]]></title>
    <url>%2F2018%2F02%2F10%2Fborder%2F</url>
    <content type="text"><![CDATA[border-radius的出现让我们实现圆角效果提供了极大的便利，我们还可以通过对Border-radius特性的进一步研究来实现各种图形效果，接下来就让我们看看它的威力吧！ 程序员必读 Css3：box-shadow高级应用 .black-theme{ margin-left: auto; margin-right: auto; margin-bottom: 20px; text-align: center; border-radius: 8px; background-color: #000; color: #fff; } 1.制作自适应的椭圆 知识点:border-radius: a / b;&nbsp;&nbsp;&nbsp;&nbsp;//a,b分别为圆角的水平、垂直半径,单位若为%,则表示相对于宽度和高度进行解析 .br-1{ width: 200px; height: 100px; border-radius: 50% /10%; background: linear-gradient(45deg,#06f,#f6c,#06c); } .br-2{ width: 100px; border-radius: 20% 50%; } .ani{ animation: skew 4s infinite; } .ani1{ animation: skew1 4s infinite 2s; } .ani2{ animation: skew2 4s infinite 3s; } @keyframes skew{ to{ border-radius: 50%; } } @keyframes skew1{ to{ border-radius: 20px 20px 100%; } } @keyframes skew2{ to{ transform: rotate(360deg); } } 核心代码 123border-radius: 50% /10%;border-radius: 20px 20px 100%;border-radius: 20% 50%; 3.纯css3实现饼图进度动画 知识点：border-radius: a b c d / e f g h; animation多动画属性; .br-31{ width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(to right,#f6c 50%,#333 0); } .br-31::before{ content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: #f6c; transform-origin: left; animation: skin 4s linear infinite, bg 8s step-end infinite; } @keyframes skin{ to{ transform: rotate(.5turn); } } @keyframes bg{ 50%{ background: #333; } } .br-32::before{ animation-play-state: paused; animation-delay: inherit; } 核心代码 123456789101112131415161718192021222324252627.br-31&#123; width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(to right,#f6c 50%,#333 0);&#125;.br-31::before&#123; content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: #f6c; transform-origin: left; animation: skin 4s linear infinite, bg 8s step-end infinite;&#125;@keyframes skin&#123; to&#123; transform: rotate(.5turn); &#125;&#125;@keyframes bg&#123; 50%&#123; background: #333; &#125;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>border-radius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[box-shadow和filter篇]]></title>
    <url>%2F2018%2F02%2F03%2Fbox-shadow%2F</url>
    <content type="text"><![CDATA[利用css3的新特性可以帮助我们实现各种意想不到的特效,下面就来一起看看吧~ 程序员必读 Css3编码技巧 1.实现水波动画 知识点：box-shadow .wave { margin-left: auto; margin-right: auto; width: 100px; height: 100px; border-radius: 100px; border: 2px solid #fff; text-align: center; line-height: 100px; color: #fff; background: #06c url(http://p3g4ahmhh.bkt.clouddn.com/me.jpg) no-repeat center center; background-size: 100%; animation: wave 4s linear infinite; } @keyframes wave { 0% { box-shadow: 0 0 0 0 rgba(245, 226, 226, 1), 0 0 0 0 rgba(250, 189, 189, 1); } 50% { box-shadow: 0 0 0 20px rgba(245, 226, 226, .5), 0 0 0 0 rgba(250, 189, 189, 1); } 100% { box-shadow: 0 0 0 40px rgba(245, 226, 226, 0), 0 0 0 20px rgba(245, 226, 226, 0); } } 核心代码123456789101112// css@keyframes wave &#123; 0% &#123; box-shadow: 0 0 0 0 rgba(245, 226, 226, 1), 0 0 0 0 rgba(250, 189, 189, 1); &#125; 50% &#123; box-shadow: 0 0 0 20px rgba(245, 226, 226, .5), 0 0 0 0 rgba(250, 189, 189, 1); &#125; 100% &#123; box-shadow: 0 0 0 40px rgba(245, 226, 226, 0), 0 0 0 20px rgba(245, 226, 226, 0); &#125;&#125; 2.实现加载动画 知识点：box-shadow多阴影 .loading { margin-left: auto; margin-right: auto; width: 30px; height: 30px; border-radius: 30px; background-color: transparent; animation: load 3s linear infinite; } @keyframes load { 0% { box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); } 30% { box-shadow: -40px 0 0 rgba(250, 189, 189, 1), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); } 60% { box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 1), 40px 0 0 rgba(250, 189, 189, 0); } 100% { box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 1); } } 核心代码1234567891011121314151617181920212223// css@keyframes load &#123; 0% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); &#125; 30% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 1), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); &#125; 60% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 1), 40px 0 0 rgba(250, 189, 189, 0); &#125; 100% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 1); &#125;&#125; 3.投影 知识点：box-shadow 1.单侧投影 .single-shadow{ margin-left: auto; margin-right: auto; width: 200px; height: 80px; background: #06c; box-shadow: 0 8px 4px -4px #666; } 核心代码1box-shadow: 0 8px 4px -4px #666; 2.双侧投影 .double-shadow{ margin-left: auto; margin-right: auto; width: 200px; height: 80px; background: #06c; box-shadow: 8px 0 10px -8px #000, -8px 0 10px -8px #000; } 核心代码12box-shadow: 8px 0 10px -8px #000, -8px 0 10px -8px #000; 3.不规则投影 .odd-shadow{ margin-left: auto; margin-right: auto; width: 200px; height: 80px; border-radius: 8px; color: #fff; font-size: 24px; text-align: center; line-height: 80px; background: #06c; filter: drop-shadow(2px 2px 2px rgba(0,0,0,.8)) } .odd-shadow::before{ content: ''; position: absolute; display: block; margin-left: -20px; transform: translateY(20px); width:0; height: 0; border: 10px solid transparent; border-right-color: #06c; } 哎呦，猪先森 核心代码12/* 注：padding/margin设置百分比单位时，是基于父元素宽度的 */filter: drop-shadow(2px 2px 2px rgba(0,0,0,.8)) 4.滤镜filter1.染色效果 .img-filter{ margin-left: auto; margin-right: auto; width: 200px; display: block; border-radius: 100%; } .img-filter-1{ filter: sepia(1) } .img-filter-2{ filter: saturate(4) } .img-filter-3{ filter: hue-rotate(295deg) } .img-filter-4{ filter: sepia(1) saturate(4) hue-rotate(295deg) } 原图 染色后--sepia()会给图片增加一种降饱和度的橙黄色染色效果 染色后--saturate()会给图片的每个像素提高饱和度 染色后--hue-rotate()会给每个像素的色相进以指定度数进行偏移 染色后--多个滤镜组合 核心代码 12345678/* sepia() */filter: sepia(1)/* saturate() */filter: saturate(4)/* hue-rotate() */filter: hue-rotate(295deg)/* 混合 */filter: sepia(1) saturate(2) hue-rotate(100deg) 2.模糊效果 .img-blur{ margin-left: auto; margin-right: auto; width: 80px; height: 80px; border-radius: 8px; text-align: center; background-color: rgba(100,100,255,1); filter: blur(20px); color: #000; } Mr XuJiang, Love you. 核心代码 1filter: blur(20px);]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>box-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border和background篇]]></title>
    <url>%2F2018%2F01%2F30%2Fanimation%2F</url>
    <content type="text"><![CDATA[自从有了Css3 transition和animation以来,前端开发在动画这一块有了更高的自由度和格局,对动画的开发也越来越容易.这篇文章就让我们汇总一下使用Css3实现的各种特效. 程序员必读 Css3编码技巧 .black-theme{ margin-left: auto; margin-right: auto; margin-bottom: 20px; text-align: center; border-radius: 8px; background-color: #000; color: #fff; } 1.实现内部虚线边框 知识点：outline .dash-border{ width: 200px; height: 100px; line-height: 100px; outline: 1px dashed #fff; outline-offset: -10px; } hello world 核心代码12345// css.dash-border&#123; outline: 1px dashed #fff; outline-offset: -10px;&#125; 2.边框内圆角的实现 知识点：box-shadow .radius-border{ margin-top: 20px; width: 180px; height: 80px; box-shadow: 0 0 0 10px gray; } 核心代码 1box-shadow: 0 0 0 10px gray; 3.实现条纹背景与进度条 知识点：linear-gradient,repeating-linear-gradient .bg-stripe{ margin-top: 20px; width: 180px; height: 20px; background: linear-gradient(to right,#fb3 50%,#58a 0); background-size: 40px 100%; box-shadow: inset 0 0 3px #555; } .bg-stripe-2{ background: linear-gradient(45deg,#fb3 25%,#58a 0,#58a 50%,#fb3 0,#fb3 75%,#58a 0); background-size: 40px 40px; } .bg-stripe-3{ background: repeating-linear-gradient(60deg,#fb3,#fb3 15px,#58a 0,#58a 30px); } 核心代码 12345678910// 上background: linear-gradient(to right,#fb3 50%,#58a 0);background-size: 40px 100%;// 中background: linear-gradient(45deg,#fb3 25%,#58a 0,#58a 50%,#fb3 0,#fb3 75%,#58a 0);background-size: 40px 40px;// 下 (可以实现任意角度的渐变，45°时显示效果最好)background: repeating-linear-gradient(60deg,#fb3,#fb3 15px,#58a 0,#58a 30px); 4.复杂的背景图案 知识点：linear-gradient,repeating-linear-gradient,radial-gradient .bg-grid{ margin-top: 20px; width: 200px; height: 200px; background-image: linear-gradient(rgba(255,255,255,1) 2px,transparent 0), linear-gradient(to right,rgba(255,255,255,1) 2px,transparent 0), linear-gradient(rgba(255,255,255,.2) 1px,transparent 0), linear-gradient(to right,rgba(255,255,255,.2) 1px,transparent 0); background-position: -50px -50px; background-size: 100px 100px,100px 100px, 100% 10px, 10px 100%; } .animate-grid{ animation: move-grid 6s linear infinite; } @keyframes move-grid{ 0%{ background-position: -50px -50px; } 30%{ background-position: -100px -100px; } 60%{ background-position: -100px -150px; } 100%{ background-position: -50px -50px; } } 核心代码 1234567// 1background-image: linear-gradient(rgba(255,255,255,1) 2px,transparent 0), linear-gradient(to right,rgba(255,255,255,1) 2px,transparent 0), linear-gradient(rgba(255,255,255,.2) 1px,transparent 0), linear-gradient(to right,rgba(255,255,255,.2) 1px,transparent 0); background-position: -50px -50px; background-size: 100px 100px,100px 100px, 100% 10px, 10px 100%; .bg-dot{ margin-top: 20px; width: 200px; height: 50px; background-image: radial-gradient(circle,#0cf 15px,transparent), radial-gradient(circle,red 15px,transparent), radial-gradient(circle,yellow 15px,transparent), radial-gradient(circle,green 15px,transparent); background-repeat: no-repeat; background-position: 0 0, 50px 0, 100px 0, 150px 0, 200px 0; background-size: 50px 50px; } .animate-dot{ animation: move-dot 8s linear infinite; } .animate-dot2{ animation: move-dot2 6s linear infinite; } @keyframes move-dot{ 0%{ background-position: 0 0, 50px 0, 100px 0, 150px 0; } 30%{ background-position: 50px 0, 0 0, 100px 0, 150px 0; } 60%{ background-position: 50px 0, 100px 0, 0 0, 150px 0; } 100%{ background-position: 50px 0, 100px 0, 150px 0, 0 0; } } @keyframes move-dot2{ 0%{ background-image: radial-gradient(circle,#0cf 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent); } 30%{ background-image: radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,red 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent); } 60%{ background-image: radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,yellow 15px,transparent), radial-gradient(circle,gray 15px,transparent); } 100%{ background-image: radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,green 15px,transparent); } } 核心代码 12345678// 利用css3多背景和position实现红绿灯和背景色块移动background-image: radial-gradient(circle,#0cf 15px,transparent), radial-gradient(circle,red 15px,transparent), radial-gradient(circle,yellow 15px,transparent), radial-gradient(circle,green 15px,transparent); background-repeat: no-repeat; background-position: 0 0, 50px 0, 100px 0, 150px 0, 200px 0; background-size: 50px 50px; .bg-qi{ margin-top: 20px; width: 200px; height: 200px; background-color: #eee; background-image: linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0), linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0); background-position: 0 0, 20px 20px; background-size: 40px 40px; box-shadow: 2px 2px 4px rgba(0,0,0,.4); } 核心代码 12345// 利用背景渐变实现棋盘图案background-image: linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0), linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0);background-position: 0 0, 20px 20px;background-size: 40px 40px; 伪随机背景 .bg-line-rand{ margin-top: 20px; width: 480px; height: 60px; background-color: #eee; background-image: linear-gradient(90deg,#fb3 11px, transparent 0), linear-gradient(90deg,#ab4 23px, transparent 0), linear-gradient(90deg,#655 41px, transparent 0); background-size: 41px 100%, 61px 100%, 83px 100%; box-shadow: 2px 2px 4px rgba(0,0,0,.4); } .bg-dot-rand{ margin-top: 20px; width: 200px; height: 200px; background-color: #eee; background-image: radial-gradient(circle,#fb3 5px, transparent 0), radial-gradient(circle,#ab4 13px, transparent 0), radial-gradient(circle,#655 31px, transparent 0); background-repeat: no-repeat; background-size: 101px 203px, 147px 60px, 373px 201px; box-shadow: 2px 2px 4px rgba(0,0,0,.4); } .animate1{ animation: move 4s linear infinite; } .animate2{ animation: move2 4s linear infinite; } @keyframes move{ 0%{ background-position: 0 0, 0 0, 0 0; } 50%{ background-position: -10px 0, 20px 0, 30px 0; } 100%{ background-position: 0 0, 30px 0, 10px 0; } } @keyframes move2{ 0%{ background-position: 0 0, 0 0, 0 0; } 50%{ background-position: -10px 30px, 20px 0, -40px 80px; } 100%{ background-position: 0 20px, 60px -20px, 10px 30px; } } 核心代码 12345678910111213// 利用背景渐变实现棋盘图案/*线性*/background-image: linear-gradient(90deg,#fb3 11px, transparent 0), linear-gradient(90deg,#ab4 23px, transparent 0), linear-gradient(90deg,#655 41px, transparent 0); background-size: 41px 100%, 61px 100%, 83px 100%;/*径向*/background-image: radial-gradient(circle,#fb3 5px, transparent 0), radial-gradient(circle,#ab4 13px, transparent 0), radial-gradient(circle,#655 31px, transparent 0);background-repeat: no-repeat;background-size: 101px 203px, 147px 60px, 373px 201px; 5.折角效果 知识点：linear-gradient 1.折角效果 .fold{ margin-left: auto; margin-right: auto; margin-bottom: 20px; width: 200px; height: 80px; color: #fff; line-height: 80px; text-align: center; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.5) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg,transparent 1.4em,#06c 0); } .linear{ background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.5)) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg,transparent 1.4em,#06c); } 折角效果哦 折角效果哦 核心代码 12background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.5) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg,transparent 1.4em,#06c 0); 2.内阴影圆折角效果 .fold-1{ margin-left: auto; margin-right: auto; margin-bottom: 20px; position: relative; width: 200px; height: 80px; border-radius: .5em; color: #fff; line-height: 80px; text-align: center; background: linear-gradient(-150deg,transparent 1.5em, #58a 0); } .fold-1::before{ content: ""; position: absolute; top: 0; right: 0; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.2) 0,rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; transform: translateY(-1.3em) rotate(-30deg); transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15); } 折角效果哦 核心代码 1234567891011121314151617181920212223242526.fold-1&#123; margin-left: auto; margin-right: auto; margin-bottom: 20px; position: relative; width: 200px; height: 80px; border-radius: .5em; color: #fff; line-height: 80px; text-align: center; background: linear-gradient(-150deg,transparent 1.5em, #58a 0);&#125;.fold-1::before&#123; content: ""; position: absolute; top: 0; right: 0; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.2) 0,rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; transform: translateY(-1.3em) rotate(-30deg); transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15);&#125; 6.自适应文本的条纹背景 知识点：linear-gradient,line-height,background-origin .stripe-bg{ padding: .5em; line-height: 1.5em; background: beige; background-size: auto 3em; background-origin: content-box; background-image: linear-gradient(rgba(0,0,0,.2) 50%, transparent 0); } .stripe-bg > p{ margin: 0; } hello you hello you hello you hello you hello you 7.自定义的下划线实现 知识点linear-gridient .my-line{ line-height: 1.4em; background: linear-gradient(gray,gray) no-repeat; background-size: 100% 1px; background-position: 0 1.15em; text-shadow: .05em 0 #fff, -.05em 0 #fff; } i have your big apple.you have a too? hi hi hi. 小伙伴们注意到了吗？默认的下划线会将文字穿过，而上面的不会呦！ 12345678# 核心代码.my-line&#123; line-height: 1.4em; background: linear-gradient(gray,gray) no-repeat; background-size: 100% 1px; background-position: 0 1.15em; text-shadow: .05em 0 #fff, -.05em 0 #fff;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>outline</tag>
        <tag>radial-gradient</tag>
        <tag>linear-gradient</tag>
        <tag>box-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客测试]]></title>
    <url>%2F2018%2F01%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎访问猪先森的博客,这篇文章是教你如何快速创建一个基于HEXO的博客,涉及到node和npm的相关使用,如果你是一枚程序猿,如果你还没有一个上手的博客,哈哈,你懂的,赶快来围观吧！ 快速开始创建一个博客文章页面1$ hexo new "My New Post" 更多参考: Writing 运行服务器1$ hexo server 更多参考: Server 生成静态文件1$ hexo generate 更多参考: Generating 发布到远程站点1$ hexo deploy 更多参考: Deployment hexo高级技巧 实现博客页面自定义交互 1&lt;escape&gt;在此标签内的元素可以不被hexo解析&lt;/escape&gt;]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
