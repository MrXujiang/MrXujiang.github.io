<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6总结]]></title>
    <url>%2F2018%2F04%2F18%2Fes6%2F</url>
    <content type="text"><![CDATA[ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。ES6给我们提供了很多js的新特性和规范，使得我们编写Js代码更加灵活和强大，接下来让我们来学习一下吧。 let和constlet声明的变量只在它所在的代码块有效。for循环计数很适合此变量123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 不存在变量提升ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。let不允许在相同作用域内，重复声明同一个变量考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错 const声明一个只读的常量。一旦声明，常量的值就不能改变 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心 123456789// 将对象彻底冻结var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 变量的解构赋值解构赋值允许指定默认值12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构 数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值 123456789101112// p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量 1let &#123; log, sin, cos &#125; = Math; 字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象 12345678910const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o"// 获取字符串长度let &#123;length : len&#125; = 'hello';len // 5 字符串扩展字符基础 JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。汉字“𠮷”的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 字符串的遍历器接口 ES6 为字符串添加了遍历器接口,使得字符串可以被for…of循环遍历。 includes(), startsWith(), endsWith() includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let d = 'Hello world!';// 第二个参数表示开始搜索的位置，endsWith第二个参数不同，针对前n个字符d.startsWith('world', 6) // trued.endsWith('hello', 5) // trued.includes('Hello', 6) // false repeat() repeat方法返回一个新字符串，表示将原字符串重复n次如果repeat的参数是负数或者Infinity，会报错。如果repeat的参数是字符串，则会先转换成数字参数NaN等同于 0 123'hello'.repeat(2) // "hellohello"'na'.repeat(0) // ""'aa'.repeat(2.3) // 'aaaa' 参数如果是小数会被取整 padStart()，padEnd() 字符串补全12345678'x'.padStart(5, 'ab') // 'ababx''x'.padEnd(4, 'ab') // 'xaba'// 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串'ssss'.padStart(3,'dd') // 'ssss'// 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串'abc'.padStart(10, '0123456789') // '0123456abc'// 如果省略第二个参数，默认使用空格补全长度'ss'.padStart(10) // ' ss' 模板字符串 ${} 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性模板字符串之中还能调用函数 123456789101112131415161718192021222324// 简单的模板函数const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`;const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 标签模板 tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推 123456789101112131415161718let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; let result = ''; let i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // "The total is 30 (31.5 with tax)" “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; String.raw() String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用 123456String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 "Hi\\n5!"`Hi\n$&#123;2+3&#125;!` // 此时换行符/n会生效// 返回 "Hi// n5!" 正则的扩展u 修饰符 ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码 y 修饰符 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 12'a1a2a3'.match(/a\d/y) // ["a1"]'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 123456789101112131415161718192021const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;const TOKEN_G = /\s*(\+|[0-9]+)\s*/g;tokenize(TOKEN_Y, '3 + 4')// [ '3', '+', '4' ]tokenize(TOKEN_G, '3 + 4')// [ '3', '+', '4' ]function tokenize(TOKEN_REGEX, str) &#123; let result = []; let match; while (match = TOKEN_REGEX.exec(str)) &#123; result.push(match[1]); &#125; return result;&#125;tokenize(TOKEN_Y, '3x + 4')// [ '3' ]tokenize(TOKEN_G, '3x + 4')// [ '3', '+', '4' ] sticky 属性 表示是否设置了y修饰符 ,返回true/false flags 属性 返回正则表达式的修饰符 如何让 . 匹配包括换行符(行终止符)的所有字符123456//U+000A 换行符（\n）//U+000D 回车符（\r）//U+2028 行分隔符（line separator）//U+2029 段分隔符（paragraph separator）/foo[^]bar/.test('foo\nbar') // true ES5先行断言 ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。 ES5组匹配 正则表达式使用圆括号进行组匹配 123456const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 数值扩展Number.isFinite() Number.isFinite()用来检查一个数值是否为有限的（finite）,如果参数类型不是数值，一律返回false Number.isNaN() 用来检查一个值是否为NaN Number.parseInt(), Number.parseFloat() ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 Number.isInteger() Number.isInteger()用来判断一个数值是否为整数。如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数, 12// 由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。Number.isInteger(3.0000000000000002) // true Number.EPSILON 在Number对象上，新增一个极小的常量Number.EPSILON。它表示 1 与大于 1 的最小浮点数之间的差Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了 1234567// Number.EPSILON可以用来设置“能够接受的误差范围”function withinErrorMargin (express, right) &#123; return Math.abs(express) &lt; Number.EPSILON * Math.pow(2, 2);&#125;0.1 + 0.2 === 0.3 // falsewithinErrorMargin(0.1 + 0.2, 0.3) // true 安全整数和 Number.isSafeInteger() JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内 Math 对象的扩展Math.trunc() Math.trunc方法用于去除一个数的小数部分，返回整数部分对于空值和无法截取整数的值，返回NaN对于非数值，Math.trunc内部使用Number方法将其先转为数值 1234// 对于没有部署这个方法的环境，可以用下面的代码模拟Math.trunc = Math.trunc || function(x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.hypot() 返回所有参数的平方和的平方根 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 指数运算符（**） 注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。 123456789let a = 1.5;a **= 2;// 等同于 a = a * a;Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197 函数扩展函数参数的默认值1234function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125; 参数默认值的位置 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 函数的 length 属性 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123456789(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2// rest 参数不会计入length属性(function(...args) &#123;&#125;).length // 0// 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 箭头函数 大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 this指向的固定化 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数 尾调用优化 调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数 123function f(x)&#123; return g(x);&#125; 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 12345678910111213141516下面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 尾递归优化 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 蹦床函数12345678910111213141516function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125;// 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;trampoline(sum(1, 100000)) 真正的尾递归优化1234567891011121314151617181920212223242526272829unction tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 数组的扩展1.扩展运算符 将一个数组转为用逗号分隔的参数序列。如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 替代函数的 apply 方法12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 复制数组12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 合并数组12345678910var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3] 与解构赋值结合1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 字符串 JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题凡是涉及到操作四个字节的 Unicode 字符的函数，最好都用扩展运算符改写。 12[...'hello']// [ "h", "e", "l", "l", "o" ] Array.from() Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 123456789101112131415161718192021222324let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 1234567891011121314151617// Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);// 取出一组 DOM 节点的文本内容let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent)// 将数组中布尔值为false的成员转为0Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 123// Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] Array.of() 用于将一组值转化为数组 12345678Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1// 可以用以下方法模拟function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 copyWithin() 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组 12345678// 参数说明// target（必需）：从该位置开始替换数据。如果为负值，表示倒数。// start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。这两个方法都可以接受第二个参数，用来绑定回调函数的this对象 1234567891011121314151617181920212223// find[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10// findIndex[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2// 第二个参数function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26// indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 数组实例的 fill() ill方法使用给定值，填充一个数组 123456789101112['a', 'b', 'c'].fill(7)// [7, 7, 7]// fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c']// 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。let arr = new Array(3).fill(&#123;name: "Mike"&#125;);arr[0].name = "Ben";arr// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;] 数组实例的 entries()，keys() 和 values() ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 123456// 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes() 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似 123456789101112131415[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true// 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true// 兼容写法const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 数组的空位 数组的空位指，数组的某一个位置没有任何值,ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位,ES6 则是明确将空位转为undefined]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能JS]]></title>
    <url>%2F2018%2F04%2F04%2Fjs-high-pf%2F</url>
    <content type="text"><![CDATA[javascript在浏览器中运行的性能，可以认为是开发者所面临的最严重的可用性问题。这个问题因为javascript的阻塞性而变得复杂，事实上，多数浏览器使用单一进程来处理用户界面和js脚本执行，所以同一时刻只能做一件事。js执行过程耗时越久，浏览器等待响应的时间越长。 加载和执行1.提高加载性能 1.IE8,FF,3.5,Safari 4和Chrome都允许并行下载js文件，当script下载资源时不会阻塞其他script的下载。但是js下载仍然会阻塞其他资源的下载，如图片。尽管脚本下载不会互相影响，但页面仍然必须等待所有js代码下载并执行完才能继续。因此仍然存在脚本阻塞问题.推荐将所有js文件放在body标签底部以减少对整个页面的影响。 2.减少页面外链脚本文件的数量将会提高页面性能：http请求会带来额外的开销，因此下载单个300k的文件将比下载10个30k的文件效率更高。 3.动态脚本加载技术：无论何时启动下载，文件的下载和执行都不会阻塞页面其他进程。 12345678910111213141516171819202122232425262728function laodScript(url,callback)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; if(script.readyState)&#123; // ie script.onreadystatechange = function()&#123; if(script.readyState == 'loaded' || script.readyState == 'complete')&#123; script.onreadystatechange = null; callback() &#125; &#125; &#125;else&#123; //其他浏览器 script.onload = function()&#123; callback() &#125; &#125; script.src = url; document.getElementsByTagName('head')[0].appendChild(script);&#125;// 使用loadScript('./a.js',function()&#123; loadScript('./b.js',function()&#123; loadScript('./c.js',function()&#123; console.log('加载完成') &#125;) &#125;)&#125;) 4.无阻塞加载类库——LABjs,使用方法如下： 1234567891011121314&lt;script src="lab.js"&gt;&lt;/script&gt;// 链式调用时文件逐个下载，.wait()用来指定文件下载并执行完毕后所调用的函数$LAB.script('./a.js') .script('./b.js') .wait(function()&#123; App.init();&#125;)// 为了保证执行顺序，可以这么做,此时a必定在b前执行$LAB.script('./a.js').wait() .script('./b.js') .wait(function()&#123; App.init();&#125;) 2.数据存取与JS性能 1.在js中，数据存储的位置会对代码整体性能产生重大影响。数据存储共有4种方式：字面量，变量，数组项，对象成员。他们有着各自的性能特点。 2.访问字面量和局部变量的速度最快，相反，访问数组和对象相对较慢3.由于局部变量存在于作用域联的起始位置，因此访问局部变量的比访问跨域作用变量更快4.嵌套的对象成员会明显影响性能，应尽量避免5.属性和方法在原型链位置越深，访问他的速度越慢6.通常我们可以把需要多次使用的对象成员，数组元素，跨域变量保存在局部变量中来改善js性能 3.DOM编程 1.访问DOM会影响浏览器性能，修改DOM则更耗费性能，因为他会导致浏览器重新计算页面的几何变化。&lt;通常的做法是减少访问DOM的次数，把运算尽量留在JS这一端。 注：如过在一个对性能要求比较高的操作中更新一段HTML，推荐使用innerHTML，因为它在绝大多数浏览器中运行的都很快。但对于大多数日常操作而言，并没有太大区别，所以你更应该根据可读性，稳定性，团队习惯，代码风格来综合决定使用innerHTML还是createElement() 2.HTML集合优化 HTML集合包含了DOM节点引用的类数组对象，一直与文档保持连接，每次你需要最新的信息时，都会重复执行查询操作，哪怕只是获取集合里元素的个数。 1.优化一——集合转数组collToArr 123456function collToArr(coll)&#123; for(var i=0, a=[], len=coll.length; i&lt;len; i++)&#123; a.push(coll[i]); &#125; return a&#125; 2.缓存集合length3.访问集合元素时使用局部变量（即将重复的集合访问缓存到局部变量中，用局部变量来操作） 3.遍历DOM 1.使用只返回元素节点的API遍历DOM,因为这些API的执行效率比自己实现的效率更高： 属性名被替代属性 childrenchildNodes childElementCountchildNodes.length firstElementChildfirstChild lastElementChildlastChild nextElementSiblingnextSibling previousElementSiblingpreviousSibling 2.选择器API——querySelectorAll() querySelectorAll()方法使用css选择器作为参数并返回一个NodeList——包含着匹配节点的类数组对象，该方法不会返回HTML集合，因此返回的节点不会对应实时文档结构，着也避免了HTML集合引起的性能问题。1let arr = document.querySelectorAll('div.warning, div.notice &gt; p') 4.重绘和重排 浏览器在下载完页面的所有组件——html,js,css,图片等之后，会解析并生成两个内部数据结构—— DOM树，渲染树.一旦DOM树和渲染树构建完成，浏览器就开始绘制页面元素（paint）. 1.重排发生的条件： 添加或删除可见的DOM元素位置变化元素尺寸改变内容改变页面渲染器初始化浏览器窗口尺寸变化出现滚动条时会触发整个页面的重排 重排必定重绘 5.渲染树变化的排列和刷新 大多数浏览器通过队列化修改并批量执行来优化重排过程，然而获取布局信息的操作会导致队列强制刷新。 1234offsetTop,offsetWidth...scrollTop,scrollHeight...clientTop,clientHeight...getComputedStyle() 一些优化建议：将设置样式的操作和获取样式的操作分开： 123456// 设置样式body.style.color = 'red';body.style.fontSize = '24px'// 读取样式let color = body.style.colorlet fontSize = body.style.fontSize 另外，获取计算属性的兼容写法： 1234function getComputedStyle(el)&#123; var computed = (document.body.currentStyle ? el.currentStyle : document.defaultView.getComputedStyle(el,''); return computed&#125; 6.最小化重绘和重排 1.批量改变样式 12/* 使用cssText */el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 20px'; 2.批量修改dom的优化方案——使元素脱离文档流-对其应用多重改变-把元素带回文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445function appendDataToEl(option)&#123; var targetEl = option.target || document.body, createEl, data = option.data || []; // 让容器脱离文档流，减少重绘重排 var targetEl_display = targetEl.style.display; targetEl.style.display = 'none'; // *****创建文档片段来优化Dom操作**** var fragment = document.createDocumentFragment(); // 给元素填充数据 for(var i=0, max = data.length; i&lt; max; i++)&#123; createEl = document.createElement(option.createEl); for(var item in data[i])&#123; if(item.toString() === 'text')&#123; createEl.appendChild(document.createTextNode(data[i][item])); continue; &#125; if(item.toString() === 'html')&#123; createEl.innerHTML = item,data[i][item]; continue; &#125; createEl.setAttribute(item,data[i][item]); &#125; // ****将填充好的node插入文档片段**** fragment.appendChild(createEl); &#125; // ****将文档片段统一插入目标容器**** targetEl.appendChild(fragment); // 显示容器，完成数据填充 targetEl.style.display = targetEl_display;&#125;// 使用var wrap = document.querySelectorAll('.wrap')[0];var data = [ &#123;name: 'xujaing',text: '选景', title: 'xuanfij'&#125;, &#123;name: 'xujaing',text: '选景', title: 'xuanfij'&#125;, &#123;name: 'xujaing',text: '选景', title: 'xuanfij'&#125;];appendDataToEl(&#123; target: wrap, createEl: 'div', data: data&#125;); 上面的优化方法使用了文档片段: 当我们把文档片段插入到节点中时，实际上被添加的只是该片段的子节点，而不是片段本身。可以使得dom操作更有效率。 3.缓存布局信息 1234567//缓存布局信息let current = el.offsetLeft;current++;el.style.left = current + 'px';if(current &gt; 300)&#123; stop();&#125; 4.慎用:hover 如果有大量元素使用:hover,那么会降低相应速度，CPU升高 5.使用事件委托（通过事件冒泡实现）来减少事件处理器的数量，减少内存和处理时间 1234567891011121314151617function delegation(e,selector,callback)&#123; e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName !== selector || target.className !== selector || target.id !== selector)&#123; return; &#125; if(typeof e.preventDefault === 'function')&#123; e.preventDefault(); e.stopPropagation(); &#125;else&#123; e.returnValue = false; e.cancelBubble = true; &#125; callback()&#125; 4.算法和流程控制 1.循环中减少属性查找并反转(可以提升50%-60%的性能) 123456789// for 循环for(var i=item.length; i--)&#123; process(item[i]);&#125;// while循环var j = item.length;while(j--)&#123; process(item[i]);&#125; 2.使用Duff装置来优化循环（该方法在后面的文章中会详细介绍） 3.基于函数的迭代（比基于循环的迭代慢） 123items.forEach(function(value,index,array)&#123; process(value);&#125;) 4.通常情况下switch总比if-else快，但是不是最佳方案 5.字符串和正则表达式 1.除了IE外，其他浏览器会尝试为表达式左侧的字符串分配更多的内存，然后简单的将第二个字符串拷贝到他的末尾，如果在一个循环中，基础字符串位于最左侧，就可以避免重复拷贝一个逐渐变大的基础字符串。2.使用[\s\S]来匹配任意字符串3.去除尾部空白的常用做法： 12345if(!String.prototype.trim)&#123; String.prototype.trim = function()&#123; return this.replace(/^\s+/,'').replace(/\s\s*$/, '') &#125;&#125; 6.快速响应的用户界面 1.浏览器的UI线程：用于执行javascript和更新用户界面的进程。 2.在windows系统中定时器分辨率为15毫秒，因此设置小于15毫秒将会使IE锁定，延时的最小值建议为25ms. 3.用延时数组分割耗时任务： 1234567891011121314function multistep(steps,args,callback)&#123; var tasks = steps.concat(); setTimeout(function()&#123; var task = tasks.shift(); task.apply(null, args || []); //调用Apply参数必须是数组 if(tasks.length &gt; 0)&#123; setTimeout(arguments.callee, 25); &#125;else&#123; callback(); &#125; &#125;,25);&#125; 4.记录代码运行时间批处理任务： 1234567891011121314151617function timeProcessArray(items,process,callback)&#123; var todo = item.concat(); setTimeout(function()&#123; var start = +new Date(); do&#123; process(todo.shift()); &#125;while(todo.length &gt; 0 &amp;&amp; (+new Date() - start &lt; 50)); if(todo.length &gt; 0)&#123; setTimeout(arguments.callee, 25); &#125;else&#123; callback(items); &#125; &#125;,25)&#125; 5.使用Web Worker：它引入了一个接口，能使代码运行且不占用浏览器UI线程的时间。一个Worker由如下部分组成：1.一个navigator对象，包括appName,appVersion,user Agent和platform.2.一个location对象，只读。3.一个self对象，指向全局worker对象4.一个importScripts()方法，用来加载worker所用到的外部js文件5.所有的ECMAScript对象。如object,Array,Date等6.XMLHttpRequest构造器7.setTimeout()，setInterval()8.一个close()方法，它能立刻停止worker运行 应用场景1.编码/解码大字符串2.复杂数学运算（包括图像，视屏处理）3.大数组排序 1234567891011121314151617// worker.jsvar worker = new Worker('code.js');// 接收信息worker.onmessage = function(event)&#123; console.log(event.data);&#125;// 发送数据worker.postMessage('hello');// code.js// 导入其他计算代码importScripts('a.js','b.js');self.onmessage = function(event)&#123; self.postMessage('hello' + event.data);&#125; 7.ajax优化 1.向服务器请求数据的五种方式：1.XMLHttpRequest2.Dynamic script tag insertion 动态脚本注入3.iframes4.Comet（基于http长连接的服务端推送技术）5.Multipart XHR（允许客户端只用一个http请求就可以从服务器向客户端传送多个资源） 2.单纯向服务端发送数据（beacons方法）——信标 123456789101112131415// 唯一缺点是接收到的响应类型是有限的var url = '/req.php';var params = ['step=2','time=123'];(new Image()).src = url + '?' + params.join('&amp;');// 如果向监听服务端发送回的数据，可以在onload中实现var beacon = new Image();beacon.src = ...;beacon.onload = function()&#123; ...&#125;beacon.onerror = function()&#123; ...&#125; 3.ajax性能的一些建议1.缓存数据 1.在服务端设置Expires头信息确保浏览器缓存多久响应（必须GET请求） 2.客户端把获取到的信息缓存到本地，避免再次请求 8.编程实践 1.避免重复工作 12345678910111213// 1.延迟加载var a = (x,y) =&gt;&#123; if(x &gt; 4)&#123; a = 0; &#125;else&#123; a = 1; &#125;&#125;// 需要使用时调用a();// 2.条件预加载（适用于函数马上执行并频繁操作的场景）var b = a &gt; 0 ? '4' : '0'; 2.使用Object/Array字面量3.多用原生方法 9.构建与部署高性能的js应用 1.js的http压缩当web浏览器请求一个资源时，它通常会发送一个Accept-Encoding HTTP头来告诉Web服务器它支持那种编码转换类型。这个信息主要用来压缩文档以获取更快的下载，从而改善用户体验。Accept-Encoding可用的值包括：gzip,compress,deflate,identity.如果Web服务器在请求中看到这些信息头，他会选择最合适的编码方式，并通过Content-Encoding HTTP头通知WEB浏览器它的决定。2.使用H5离线缓存3.使用内容分发网络4.对页面进行性能分析 123456789101112131415// 检测代码运行时间var Timer = &#123; _data: &#123;&#125;, start: function(key)&#123; Timer._data[key] = new Date(); &#125;, stop: function(key)&#123; var time = Timer._data[key]; if(time)&#123; Timer._data[key] = new Date() - time; &#125;; console.log(Timer._data[key]); return Timer._data[key] &#125;&#125;;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB学习指南]]></title>
    <url>%2F2018%2F03%2F30%2FmongoDB%2F</url>
    <content type="text"><![CDATA[Mongodb是分布式文档存储数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个高性能，开源，无模式的文档型数据库，是当前NoSql数据库中比较热门的一种。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式,接下来就让我们学习一下它吧! 安装和配置 mongoDB安装教程 1.基本操作 12345678910111213141516# 启动数据库服务（--dbpath后的路径代表指定数据库的路径）mongod --dbpath c:\mongoDB\data\db# 连接数据库mongo# 查看数据库show dbs# 切换/创建数据库use [数据库名]# 删除数据库1.先切换到想要删除的数据库2.执行命令: db.dropDatabase()# 创建集合并插入数据 如果集合不存在mongoDB会自动创建并插入文档db.class_name.insert(&#123;name:"一班"&#125;)# 删除集合db.collection_name.drop() 2.查询 1234567891011121314151617# 查找集合中的文档db.collection_name.find()# 以易读的方式查看查询的文档db.collection_name.find().pretty()# 除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。# MongoDB 的 find() 方法可以传入多个键(key),类似于sql的anddb.collection_name.find(&#123;key: 1, name:"xx"&#125;)# 或条件查询,类似于sql的ordb.col.find(&#123;$or:[&#123;"by":"菜鸟教程"&#125;,&#123;"title": "MongoDB 教程"&#125;]&#125;)# AND 和 OR 联合使用db.col.find(&#123;"likes": &#123;$gt:50&#125;, $or: [&#123;"by": "Mongodb中文网"&#125;,&#123;"title": "MongoDB 教程"&#125;]&#125;)# 条件操作符 -- $gt 大于; $gte 大于等于; $lt 小于; $lte 小于等于; 使用如下:db.col.find(&#123;num: &#123;$gt: 100&#125;&#125;) # 查询num值大于100的数据 3.更新修改和删除集合中的文档 123456789101112131415# 更新集合中的数据db.collection_name.update(&#123;更新前的数据&#125;,&#123;更新后的数据&#125;)# 列如:db.user.update(&#123;x:1&#125;,&#123;x:99&#125;)# 如果某一条数据有多个字段,则为了避免不覆盖,应该使用$set,其为部分操作符,$set后存在的字段将被更新,不存在的不会更新,如:db.user.update(&#123;z:1&#125;,&#123;$set:&#123;y:22&#125;&#125;)# 如果更新的数据不存在,则插入一条新数据,需要用到update第三个参数,设为truedb.user.update(&#123;z:003&#125;,&#123;y:33&#125;,true)# update默认值只更新找到的第一条数据,如果要求更新所有查询到的数据,则要使用$set和将第四个参数设为true.如:db.user.update(&#123;x:"xx"&#125;,&#123;$set:&#123;x:"xdf"&#125;&#125;,false,true)# 删除数据 remove(&#123;&#125;)内的参数必填,默认删除所有找到的数据db.user.remove(&#123;x:"22"&#125;) # 删除找到的所有x:22的数据db.user.remove(&#123;&#125;) # 删除集合中所有数据sb.user.remove(&#123;x:22&#125;,true/1) # 删除找到的第一条数据 3.2 mongoDB修改器深入 123456789101112# $inc 可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作db.user.update(&#123;num:2&#125;,&#123;$inc:&#123;num:1&#125;&#125;) # 每次执行对num增加1,默认只对第一个匹配的执行# $set 用来指定一个键并更新键值，若键不存在并创建db.a.update(&#123;"uid" : "22","type" : "3"&#125;,&#123;$set:&#123;"size":10&#125;&#125;)db.c.update(&#123;"name":"toyota"&#125;,&#123;"$set":&#123;"size.width":7&#125;&#125;) # $set通过.语法修改内嵌文档# $unset 用来删除键. 使用时，不论对目标键使用1、0、-1或者具体的字符串等都是可以删除该目标键db.a.update(&#123;"uid" : "02","type" : "3"&#125;,&#123;$unset:&#123;"size":-1&#125;&#125;)# 数组修改器 $push--向文档的某个数组类型的键添加一个数组元素，不过滤重复的数据。添加时键存在，要求键值类型必须是数组；键不存在，则创建数组类型的键db.c.update(&#123;"name" : "toyota"&#125;,&#123;$push:&#123;"title":"t1"&#125;&#125;) 4.索引 123456789101112131415161718192021222324252627282930# 查看集合索引db.user.getIndexes()# 创建索引 --单一索引 -- 1 表示正序, -1 表示逆序db.user.ensureIndex(&#123;x:1&#125;)# 过期索引--一段时间后会过期的索引,索引过期后数据也会被清除# 过期索引的限制:过期索引字段的值必须是指定的时间类型,即IOSDate或IOS数组,不能是时间戳# 如果指定了时间数组,则按最小的时间进行删除# 过期索引不能是复合索引# 过期索引是不精确的db.user.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:10&#125;)# 全文索引 --索引字段"text"为必填字段 -- 一个集合只能有一个全文索引db.user.ensureIndex(&#123;name:"text"&#125;) #对单一字段创建全文索引db.user.ensureIndex(&#123;"$**":"text"&#125;) #对集合中所有字段创建全文索引# 使用方式:db.user.find(&#123;$text:&#123;$search:"aa bb"&#125;&#125;) #在集合中查询有aa或bb字段的数据文档db.user.find(&#123;$text:&#123;$search:"aa -cc"&#125;&#125;) #在集合中查询有aa字段但不包含cc字段的文档db.user.find(&#123;$text:&#123;$search:"\"aa\" \"bb\""&#125;&#125;) #在集合中查询有aa并且有bb字段的文档# 全文索引相似度 -- &#123;score:&#123;$meta:"textScore"&#125;&#125; db.user.find(&#123;$text:&#123;$search:"aa"&#125;&#125;,&#123;score:&#123;$meta:"textScore"&#125;&#125;).sort(&#123;score:&#123;$meta:"textScore"&#125;&#125;) # 显示相似度并根据相似度排序# 全文索引的限制1.每次查询只能指定一个$text2.$text查询不能出现在$nor查询中3.目前不支持中文4.查询中如果包含$text,则hint将不再起作用]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用工具函数汇总]]></title>
    <url>%2F2018%2F03%2F18%2Fjs-tools%2F</url>
    <content type="text"><![CDATA[下面给大家梳理了我平时在工作中常用的js方法，本来是打算作为自己的工具库的，为了发现代码的最佳方案，再此贴出，望相互交流。 程序员必读 Css3编码技巧 1.检测平台（设备）类型12345var isWechat = /micromessenger/i.test(navigator.userAgent), isWeibo = /weibo/i.test(navigator.userAgent), isQQ = /qq\//i.test(navigator.userAgent), isIOS = /(iphone|ipod|ipad|ios)/i.test(navigator.userAgent), isAndroid = /android/i.test(navigator.userAgent); 2.时间格式化12345678910111213// 时间格式化function format_date(timeStamp) &#123; var date = new Date(timeStamp); return date.getFullYear() + "年" + prefix_zero(date.getMonth() + 1) + "月" + prefix_zero(date.getDate()) + "日 " + prefix_zero(date.getHours()) + ":" + prefix_zero(date.getMinutes());&#125;// 数字格式化function prefix_zero(num) &#123; return num &gt;= 10 ? num : "0" + num;&#125; 3.倒计时函数123456789101112131415// 倒计时时间格式化function format_time(timeStamp) &#123; var day = Math.floor(timeStamp / (24 * 3600 * 1000)); var leave1 = timeStamp % (24 * 3600 * 1000); var hours = Math.floor(leave1 / (3600 * 1000)); var leave2 = leave1 % (3600 * 1000); var minutes = Math.floor(leave2 / (60 * 1000)); var leave3 = leave2 % (60 * 1000); var seconds = Math.floor(leave3 / 1000); if (day) return day + "天" + hours + "小时" + minutes + "分"; if (hours) return hours + "小时" + minutes + "分" + seconds + "秒"; if (minutes) return minutes + "分" + seconds + "秒"; if (seconds) return seconds + "秒"; return "时间到！";&#125; 4.判断设备是否支持触摸事件1var isSupportTouch = ("ontouchstart" in document.documentElement) ? true : false; 5.js+rem实现移动端适配123456789101112131415161718192021222324252627(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; var fontSize = 20; docEl.style.fontSize = fontSize + 'px'; var docStyles = getComputedStyle(docEl); var realFontSize = parseFloat(docStyles.fontSize); var scale = realFontSize / fontSize; console.log("realFontSize: " + realFontSize + ", scale: " + scale); fontSize = clientWidth / 667 * 20; if(isIphoneX()) fontSize = 19; fontSize = fontSize / scale; docEl.style.fontSize = fontSize + 'px'; &#125;; // Abort if browser does not support addEventListener if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); // iphoneX判断 function isIphoneX()&#123; return /iphone/gi.test(navigator.userAgent) &amp;&amp; (screen.height == 812 &amp;&amp; screen.width == 375) &#125;&#125;)(document, window); 6.检查是否为中文1let isCN = (str) =&gt; &#123; return /^[\u4e00-\u9fa5]*$/.test(str) &#125; 7.禁用enter表单自动提交1234567891011121314151617181920212223//禁用Enter键表单自动提交 document.onkeydown = function(event) &#123; var target, code, tag; if (!event) &#123; event = window.event; //针对ie浏览器 target = event.srcElement; code = event.keyCode; if (code == 13) &#123; tag = target.tagName; if (tag == "TEXTAREA") &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; else &#123; target = event.target; //针对遵循w3c标准的浏览器，如Firefox code = event.keyCode; if (code == 13) &#123; tag = target.tagName; if (tag == "INPUT") &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125; &#125;;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css2.0深入探究]]></title>
    <url>%2F2018%2F03%2F17%2Fcss2-01%2F</url>
    <content type="text"><![CDATA[要想深入一个事物，最好对其总体有个大体的了解。要想学好css,最好对其进行深入的研究，让自己对其有足够的控制感，这样才能发挥css最大的价值。 程序员必读 Css3编码技巧 1.css尺寸1.首选最小宽度–实现复杂图形效果 在css中，图片和文字的权重远大于布局，因此当width:0时表现出来的宽度就是“首选最小宽度”。中文的最小宽度为每个汉字的宽度，西方文字取决于连续的英文字符单元。 .win-wrap{ text-align: center; } .minW{ display: inline-block; width: 0; line-height: 1.4; } .minW::before{ content: "love 你 love"; color: transparent; outline: 2px solid #cd0000; } .minW:hover::before{ content: "你 love 我"; color: transparent; outline: 2px solid #cd0000; } 123456789.minW&#123; display: inline-block; width: 0&#125;.minW:hover::before&#123; content: "你 love 我"; color: transparent; outline: 2px solid #cd0000;&#125; 2.子元素宽度设为100%时的奇怪现象原理探究 父元素的宽度 = 图片宽度 + 文字内容宽度浏览器渲染原理：先下载文档内容，加载头部样式资源，然后按从上到下、自外而内的顺序渲染dom内容。本例的现象产生的原因就是：当渲染到父元素时，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素的宽度已经固定，此时的width:100%就是以固定好的父元素的宽度，宽度不够只能溢出。 .box{ margin-left: 50%; transform: translateX(-50%); display: inline-block; height: 100px; white-space: nowrap; background-color: rgba(0,0,0,.4); } .img{ display: inline-block; width: 120px; text-align: center; } .text{ display: inline-block; width: 100%; color: #fff; background-color: #06c; } img 半透明背景色是父级width:100% 12345678.box&#123; display: inline-block; white-space: nowrap;&#125; .text&#123; display: inline-block; width: 100%;&#125; 3.如何让元素支持height:100%效果* 1.设置显示的高度值 * 2.使用绝对定位 知识点：绝对定位的宽高百分比是基于padding-box的，而非绝对定位的宽高百分比是基于content-box 4.任意高度元素的展开收起动画(max-height/min-height)* 1.min-height/min-width的初始尺寸为auto, max-height/max-width的初始尺寸为none * 2.min-height/min-width的优先级高于max-width/max-height .navbar{ width: 200px; margin: 20px auto; text-align: center; } .nav{ border-bottom: 2px solid #06c; cursor: pointer; } .nav > .sub-nav{ max-height: 0; overflow: hidden; transition: max-height .6s cubic-bezier(.17,.67,.76,1.41) } .nav:hover > .sub-nav{ max-height: 400px; } .sub-nav > div:hover{ color: #fff; background: #06c; } 首页 花朵 云彩 DIV 12345678.nav &gt; .sub-nav&#123; max-height: 0; overflow: hidden; transition: max-height .6s cubic-bezier(.17,.67,.76,1.41)&#125;.nav:hover &gt; .sub-nav&#123; max-height: 400px;&#125; 5.内联元素深入探究 常见的内联元素有：display设置为inline,inline-block,inline-table的元素内联盒模型: 1. 内容区域：可以理解为文本选中的背景色区域(重点) 2. 内联盒子：内联标签或者纯文本 3. 行框盒子：由内联盒子组成的一行，每一行就是一个行框盒子 4. 包含盒子：由行框盒子组成的盒子 幽灵空白节点：在HTML5文档声明中，内联元素的解析和渲染表现就像每个行框盒子的前面有一个空白节点一样。如下案例所示： .in-ex{ background: #06c; } 1&lt;div class="in-ex"&gt;&lt;span style="display: inline-block"&gt;&lt;/span&gt;&lt;/div&gt; 6.深入理解content 1.在web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包含边框）为300*150，如video,iframe,canvas等，少数为0，如img,而表单元素的替换尺寸和浏览器自身有关。 2.对于img元素，如果有css尺寸，则最终尺寸由css尺寸决定(css尺寸 &gt; html尺寸 &gt; 固有尺寸) 3.当图片的src属性缺省时，图片不会有任何请求，是最高效的实现方式，如下展示的是使用此方式的图片占位代码(对于firefox浏览器，src缺省的img是一个普通的内联元素，宽高设置无效)： 12img &#123; visibility: hidden; &#125;img[src] &#123; visibility: visible; &#125; 4.content内容生成技术 12345/* 1.实现换行 */::after&#123; content: '\A'; white-space: pre;&#125; 2.实现正在加载动画 .dot{ display: inline-block; width: 8em; height: 1em; line-height: 1; text-align: left; vertical-align: -.25em; overflow: hidden; } .dot::after{ display: block; margin-left: 5.2em; content: '...\A..\A.'; white-space: pre-wrap; animation: dot 3s infinite step-start both; } @keyframes dot{ 33% { transform: translateY(-3em);} 66% { transform: translateY(-2em);} 99% { transform: translateY(-1em);} } 正在加载中 123456789101112131415161718192021.dot&#123; display: inline-block; width: 8em; height: 1em; line-height: 1; text-align: left; vertical-align: -.25em; overflow: hidden;&#125;.dot::after&#123; display: block; margin-left: 5.2em; content: '...\A..\A.'; white-space: pre-wrap; animation: dot 3s infinite step-start both;&#125;@keyframes dot&#123; 33% &#123; transform: translateY(-3em);&#125; 66% &#123; transform: translateY(-2em);&#125; 99% &#123; transform: translateY(-1em);&#125;&#125; 3.属性值内容生成 .icon{ display: inline-block; padding: 2px 4px; border-radius: 4px; background: #000; } .icon::after{ content: attr(data-tip); } 12345&lt;div class="icon" data-tip="江小白"&gt;&lt;/div&gt;/* 可以使用原生属性和自定义属性 */.icon::after&#123; content: attr(data-tip);&#125; 4.计数器属性---纯css实现技术器效果 &gt; 知识点： content的计数器属性 .counter{ height: 100px; background: #06c; color: #fff; } .box1{ padding: 10px; counter-reset: count1; } .xigua:checked::before{ content: counter(count1); counter-increment: count1; position: absolute; color: transparent; } .box1::after{ content: counter(count1); position: absolute; margin-top: -100px; margin-left: 6em; transform: translateY(20px); border-radius: 50%; line-height: 60px; text-align: center; padding: 2px; width: 60px; height: 60px; box-sizing: border-box; color: #06c; background-color: #fff; } 西瓜 香蕉 萝卜 1234567891011121314151617181920.box1&#123; counter-reset: count1;&#125;.xigua:checked::before&#123; content: counter(count1); counter-increment: count1; position: absolute; color: transparent;&#125;.box1::after&#123; content: counter(count1);&#125;&lt;/style&gt;&lt;div class="counter"&gt; &lt;div class="box1"&gt; &lt;div&gt;西瓜&lt;input class="xigua" type="checkbox" /&gt;&lt;/div&gt; &lt;div&gt;香蕉&lt;input class="xigua" type="checkbox" /&gt;&lt;/div&gt; &lt;div&gt;萝卜&lt;input class="xigua" type="checkbox" /&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 6.padding深入研究1.对于盒模型设置为box-sizing: border-box的元素，如果padding足够大，那么width将失效: .pd-1{ margin-left: auto; margin-right: auto; background: #06c; width: 200px; padding-left: 120px; padding-right: 120px; box-sizing: border-box; color: #fff; } 内容为首选最小宽度 1234width: 200px;padding-left: 120px;padding-right: 120px;box-sizing: border-box; 2.对于内联元素，padding对视觉层和布局层都会有影响，如果父元素设置overflow:auto,则内联子元素的垂直padding可能会使父元素出现滚动条，否则如果父元素不设置设置overflow，只会在垂直方向上发生重叠，不会影响布局: .pd-2-1{ margin-left: auto; margin-right: auto; margin-bottom: 30px; background: #06c; width: 200px; box-sizing: border-box; color: #fff; } .pd-2-1 > span{ padding-top: 1em; padding-bottom: 1em; background: #f06; } .pd-2-2{ margin-left: auto; margin-right: auto; background: #06c; width: 200px; overflow: auto; box-sizing: border-box; color: #fff; } .pd-2-2 > span{ padding-top: 2em; padding-bottom: 2em; background: #f06; } 父元素不设置overflow 父元素设置overflow 12345678/* 父元素设置 */.pd-2-1&#123; overflow: auto;&#125;.pd-2-1 &gt; span&#123; padding-top: 1em; padding-bottom: 1em;&#125; 3.padding的实际应用（具体实现可自行思考） 1.增加链接或按钮的点击区域的大小 2.利用内联元素的padding实现高度可控的分割线 3.用内联元素实现瞄点定位距离 4.利用padding百分比值实现等比例缩放图片效果 .pd-3{ padding: 10% 50%; position: relative; } .pd-3 img{ position: absolute; width: 100%; height: 100%; left: 0; top: 0; } 1234567891011.pd-3&#123; padding: 10% 50%; position: relative;&#125;.pd-3 img&#123; position: absolute; width: 100%; height: 100%; left: 0; top: 0;&#125; ** 注：内联元素的垂直padding会让幽灵空白节点显现,此时可考虑设置font-size:0 5.padding与图形绘制 1.菜单图标设计 .icon-menu{ display: inline-block; margin-left: 10%; width: 120px; height: 10px; padding: 35px 0; border-bottom: 10px solid; border-top: 10px solid; background-clip: content-box; background-color: currentColor; } 2.双层圆点效果 .icon-dot{ display: inline-block; margin-left: 10%; width: 60px; height: 60px; padding: 10px; border-radius: 50%; border: 10px solid; background-clip: content-box; background-color: currentColor; } 12345678910111213141516171819202122 /* 菜单 */ .icon-menu&#123; display: inline-block; width: 120px; height: 10px; padding: 35px 0; border-bottom: 10px solid; border-top: 10px solid; background-clip: content-box; background-color: currentColor;&#125;/* 双层圆点 */.icon-dot&#123; display: inline-block; width: 60px; height: 60px; padding: 10px; border-radius: 50%; border: 10px solid; background-clip: content-box; background-color: currentColor;&#125; 7.margin深入研究 1.使用:nth-type-of(3n)去除子元素尾部margin .mg-wrap{ width: 640px; height: 100px; background: #000; } .mg-item{ float: left; width: 200px; height: 100px; background: #06c; color: #fff; text-align: center; margin-right: 20px; } .mg-item:nth-of-type(3n){ margin-right: 0; } margin-right: 20px margin-right: 20px margin-right: 20px 123.mg-item:nth-of-type(3n)&#123; margin-right: 0;&#125; 注：如果容器可以滚动，在IE和firefox下会忽略padding-bottom的值，chrome则不会，此时可以通过margin-bottom实现滚动容器的底部留白 .box-wrap{ width: 640px; height: 100px; padding: 30px 0; overflow: auto; background: #000; } .box-inner{ width: 200px; height: 200px; background: #06c; } * 其本质区别在于：chrome是子元素超过父元素content box尺寸触发滚动条显示，而IE和Firefox浏览器是超过padding box尺寸时触发滚动条显示 2.margin合并块级元素，但不包含浮动和绝对定位元素在默认文档流下只出现在垂直方向 margin合并的三种场景 1.相邻兄弟元素 2.父级和第一个/最后一个子元素* 解决方案： 父级设置为块级格式化上下文元素 父元素设置border-top/bottom值 父元素设置padding-top/bottom值 父元素设置高度 3.空块级元素margin合并 margin合并的计算规则 “正正取大值”，”正负值相加”，”负负最负值” 深入理解margin:auto 1.如果一侧定值，一侧auto，则auto为剩余空间大小 2.如果两侧均是auto，则平分剩余空间 3.触发margin:auto计算的前提：width或height为auto时，元素是具有自动填充特性的。 .father{ position: relative; margin: 20px; height: 60px; overflow: auto; background: #000; } .child-1{ width: 40px; height: 20px; background: #06c; margin-right: 20px; margin-left: auto; } .child-2{ position: absolute; left: 0; bottom: 0; right: 0; top: 0; width: 40px; height: 20px; background: #06c; margin: auto; } 123456/* 1 */margin-right: 20px;margin-left: auto;/* 2 */margin-right:auto;margin-left: auto; 绝对定位元素利用margin:auto实现水平垂直居中(兼容到ie8+) 12345678910.father&#123; position: relative;&#125;.child-2&#123; position: absolute; left: 0; bottom: 0; right: 0; top: 0; width: 40px; height: 20px; margin: auto;&#125; margin无效情形解析 display计算值为inline的非替换元素的垂直margin是无效的 对于内联替换元素，垂直margin有效，并且没有margin合并问题，所以永远不会发生margin合并 内联特性导致margin失效：一个容器里面有一个图片，图片设置margin-top,随着margin-top负值越来越大，达到某一具体负值时，图片将不再往上偏移 8.border深入研究 重置边框的高性能方案 border-width的默认值为3px,边框宽度没有半像素的概念边框样式的默认值是none,经测试以下方案性能最优 1234.border&#123; border: 2px solid #ccc; border-bottom: 0 none;&#125; border-style: double的高级用法 double的表现规则: 双线宽度永远相等，中间间隔+-1利用双线边框实现菜单按钮 .border-icon{ margin-left: auto; margin-right: auto; width: 100px; height: 20px; border-top: 60px double #06c; border-bottom: 20px solid #06c; transition: transform 1s; } .border-icon:hover{ transform: rotate(90deg); } 123456.border-icon&#123; width: 100px; height: 20px; border-top: 60px double #06c; border-bottom: 20px solid #06c;&#125; 9.字母x与css中的基线 基线 字母x的下边缘x-height 指字母x的高度ex：ex指小写字母x的高度，是相对单位vertical-align:middle 指的是基线往上1/2 x-height高度 .txt-wrap{ line-height: 1; } .f1{ font-size: 40px; vertical-align: middle } .f3{ font-size: 30px; vertical-align: middle } .f2{ display: inline-block; width: 10px; height: 2ex; background: #000; } X X 1内联元素设置对齐方式时，是基于最前面的内联元素的基线，然后根据自己的vertical-align来调整对齐的 10.line-height深入研究 1.对于非替换元素的纯内联元素，其可视高度完全由line-height决定，padding,border对其可视高度没有任何影响。2.line-height不能影响替换元素的高度 .lh-wrap{ margin-bottom: 20px; line-height: 1em; font-size: 30px; border: 1px solid #000; } .lh1{ border: 1px solid #000; } 徐r 3.line-height属性值的具体了解： 数值：如1.5，即1.5倍字体大小，此时子元素将继承1.5而不是最终父元素计算的值 百分比：如200%，子元素将继承最终计算的值 em：如2m，子元素将继承最终计算的值 4.多行文本垂直居中 .lh2-wrap{ margin: 20px auto; width: 400px; line-height: 7em; font-size: 16px; border: 1px solid #000; } .lh2-1{ display: inline-block; line-height: 2em; vertical-align: middle; } 徐rjhfj下客服打击开发商电话JFK幅度萨芬京东卡好的的JFK是否获得男子冒充 123456789/* 文本块用inline-block，借助vertical-align: middle */.lh2-wrap&#123; line-height: 7em;&#125;.lh2-1&#123; display: inline-block; line-height: 2em; vertical-align: middle;&#125; 5.计算行高时，一定要向上舍入，因为谷歌浏览器计算数值时是向下取整的6.无论内联元素line-height如何设置，最终父元素的高度都是由数值大的那个line-height决定的。 10.vertical-align深入探究 1.vertical-align的数值百分比属性值介绍： 数值： 如vertical-align: 10px; 正值往上偏移，负值往下偏移，兼容性良好 百分比： 如vertical-align: 10%; 基于line-height计算，不过不常用 2.vertical-align的作用前提： 只能应用于内联元素和display:table-cell的元素 注：1.浮动和绝对定位会让元素块状化，所以使用vertical-align时会失效 2.对于teble-cell元素而言，vertical-align作用的是自身，因为其本身有内联性质，所以对子元素设置vertical-align无效 3.vertical-align和line-height的关系重要 现象1：容器高度不等于行高 .lh3-wrap{ margin: 20px auto; width: 200px; background: #000; line-height: 32px; } .lh3-1{ /* display: inline-block; */ font-size: 28px; background: #06c; color: #fff; /* vertical-align: bottom; */ } x徐rjhfj下客 123456.lh3-wrap&#123; line-height: 32px;&#125;.lh3-1&#123; font-size: 28px;&#125; 为什么实际高度会超过32px呢？是因为幽灵空白节点的字体大小和内联元素字体大小不同，字体越大基线越低导致两个元素上下偏移，使得容器高度超过原先的设定。解决方案：1.内联元素设置对其方式为bottom或者top 2.将幽灵空白节点和内联元素字体设置成一样的 现象2. 图片底部始终留有间隙的问题 原因：是由line-height,vertical-align和和幽灵空白节点共同决定的。因为图片之前的空白节点和图片默认基线对齐，而幽灵空白节点的行高导致多余的间隙导致图片下面空出了一段距离。解决方案： 1.图片块状话化 2.容器line-height足够小 3.图片设置vertical-align为top,bottom,middle任意一种 现象3. 图片设置margin-top到一定值时无效原因： 被幽灵空白节点的vertical-align:baseline限定死了 4.应用-实现垂直剧中的弹窗 .mask{ position: fixed; /* z-index: 9999; */ display: none; left: 0; top: 0; right: 0; bottom: 0; text-align: center; background: rgba(0,0,0,.8); font-size: 0; white-space: nowrap; overflow: auto; } .mask::after{ content: ''; display: inline-block; height: 100%; vertical-align: middle; } .dialog{ display: inline-block; text-align: left; font-size: 14px; color: #fff; white-space: normal; } #show_mask{ display: inline-block; padding: 4px 10px; border-radius: 4px; background: #06c; color: #fff; cursor: pointer; } dddd 显示弹窗 var btn = document.getElementById("show_mask"), mask = document.getElementById("mask1"), isShow = false; btn.onclick = function(){ mask.style.display = "block"; isShow = true; } mask.onclick = function(){ this.style.display = "none"; isShow = false; } 1234567891011121314151617181920212223242526.mask&#123; position: fixed; /* z-index: 9999; */ left: 0; top: 0; right: 0; bottom: 0; text-align: center; background: rgba(0,0,0,.8); font-size: 0; white-space: nowrap; overflow: auto;&#125;.mask::after&#123; content: ''; display: inline-block; height: 100%; vertical-align: middle;&#125;.dialog&#123; display: inline-block; text-align: left; font-size: 14px; color: #fff; white-space: normal;&#125; 11.float作用机制 1.作用机制: 使父元素高度塌陷从而实现文字环绕效果 2.float的定位参考是行框盒子,位于哪个行框盒子后就与哪个行框盒子对齐 3.clear属性只有块级元素才有效,如果clear:both元素前面是float元素,则设置margin-top负值无效 4.clear:both后面的元素仍然可能发生文字环绕效果 12.BFC–块级格式化上下文 1.表现: 元素内部的布局变化不会影响外部的元素.所以不会出现margin合并,可用来清除浮动的影响. 2.触发BFC的条件: 根元素 float的值不为none overflow的值为auto,scroll,hidden display的值为table-cell,inline-block position的值不为static或者relative 3.若元素具备BFC特性,则无需clear:both去清除浮动 4.display:table-cell的特性: 宽度设置的再大,也不会超过表格容器的宽度 5.overflow裁切界限:border box: 一个设置了overflow: hidden的元素同时设置了padding和border,则子元素超出容器宽高设置时,裁切的边界是border box内边缘而不是padding box内边缘 6.在PC端,默认滚动条均来自,PC端滚动高度可以用document.documentElement.scrollTop获取,在移动端用document.body.scrollTop获取 7.PC端滚动条宽度约为17px 8.让页面滚动条不出现晃动的方法: 123456789101112131415html&#123; /* ie8 */ overflow-y: scroll;&#125;:root&#123; overflow-y: auto; overflow-x: hidden;&#125;:root body&#123; position: absolute;&#125;body&#123; width: 100vw; overflow: hidden;&#125; 9.多行文本溢出显示省略号的css方法: 12345.ell-rows-2&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2;&#125; 13.overflow与position:absolute 1.如果overflow不是定位元素,并且绝对定位元素和overflow容器之间没有定位元素,则overflow无法对absolute元素进行切割2.如果overflow属性值不是hidden而是auto或者scroll,则即使绝对定位元素宽高溢出也不会出现滚动条3.对于现代浏览器,如果overflow子元素transform溢出,则会裁剪’’4.overflow默认值为visible,内容不会被修剪，会呈现在元素框之外 14.absolute与clip 1.clip属性要想起作用，元素必须是absolute或者fixed,语法如下： 12/* 裁剪区域，不支持缩写和百分比值 */clip: rect(top right bottom left) 2.clip应用与渲染 1.最佳可访问性隐藏 12345/* 多用于SEO优化和对表单控件样式的优化以及屏幕阅读器的可访问性 */.clip&#123; position: absolute; clip: rect(0 0 0 0);&#125; 2.clip渲染 clip隐藏仅仅决定了哪部分是可见的，对于原来占据的空间并没有影响，非可见部分无法响应点击事件。在ie和火狐浏览器中，抹掉了不可见区域尺寸对布局的影响，chorme浏览器却保留了。 .re-box{ position: relative; width: 200px; height: 200px; background: #eee; overflow: auto; } .sb-sub{ position: absolute; width: 180px; height: 280px; clip: rect(0 0 0 0); } document.querySelector(".sb-sub").onclick = function(){ alert(1) } 12345678910111213.re-box&#123; position: relative; width: 200px; height: 200px; background: #eee; overflow: auto;&#125;.sb-sub&#123; position: absolute; width: 180px; height: 280px; clip: rect(0 0 0 0);&#125; absolute流体特性 1.absolute流体特性产生的前提： 对立方向上同时发生定位的时候 .re{ position: relative; margin-left: 10%; width: 300px; height: 300px; background: #000; } .ab{ position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin-right: 20px; margin-left: auto; background: #06c; } 123456789/* 此时设置padding和margin，其占据的空间将不变，变化的是content box的尺寸 */.ab&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: 20px;&#125; 2.absolute的margin:auto居中 .re{ position: relative; margin-left: 10%; width: 300px; height: 300px; background: #000; } .ab1{ position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 200px; height: 200px; margin: auto; background: #06c; } 12345678/* 绝对定位元素的margin:auto的填充规则和普通流体一样如果一侧定值一侧auto,auto未剩余空间大小 */.ab1&#123; position: absolute; left: 0;right: 0;top: 0;bottom: 0; width: 200px; height: 200px; margin: auto;&#125; 3.在有些场合下，百分比transform会让ios微信闪退，尽量避免用其使元素居中，可以采用absolute和margin:auto解决 15.relative难点解析 1.relative的定位位移是相对于自身的，如果left/top/right/bottom的值为百分比单位，则计算尺寸是基于父元素 2.如果left/right 或top/bottom这些对立属性同时出现时，只有一个方向的属性会生效，优先级与文档流的顺序有关，默认的文档流是自上而下，从左到右的，所以top优先级高于bottom,left优先级高于right 3.relative的最小化原则 1.尽量不使用relative,可以采用无依赖绝对定位解决某些问题2.如果一定要使用relative,则relative务必最小化（最小包含区域） –为了避免层级覆盖等问题 4.层叠上下文 1.定位元素的默认z-index:auto;此时和普通元素一样，一旦z-index设置为任意数值，就创建了一个层叠上下文，顺序为：层叠上下文 &lt; 负z-index &lt; block &lt; float &lt; inline &lt; z-index:auto &lt; 正z-index2.css3新属性的层叠上下文：1.flex2.opacity不为13.transform不为none4.mix-blend-mode不为normal5.filter不为none6.isolation是isolate7.will-change为上面2-6的任意一个8.元素-webkit-overflow-scrolling设为touch 3.z-index负值在block下面，实际应用： 1.可访问性隐藏 2.ie8下的多背景隐藏 16.字体相关 1.font-weight数值 font-weight的数值范围是100-900，值必须是整百 2.text-indent text-indent:100% 百分比值是基于当前元素的包含块计算的，即父元素宽度 3.text-indent应用–对话式排版 .t-in{ width: 80%; margin-left: 20%; } .t{ text-indent: -2em; border-bottom: 1px solid #eee; } .t:first-letter{ color: #06f; } 明：我其实一开始就知道，我喜欢你，所以，让我追你吧，用尽一切力量，守护你，呵护你，或许自己还不够成熟？是吗？那就试试看，好不好！ 红：我其实一开始就知道，我喜欢你，所以，让我追你吧，用尽一切力量，守护你，呵护你，或许自己还不够成熟？是吗？那就试试看，好不好！ 1text-indent: -2em; 4.letter-spacing 用来控制字符之间的变化，包括英文字母，汉字以及空格 其负值只能让字符重叠，不能让替换元素，inline-table发生重叠word-spacing是单词间距 5.按钮之间的间距可以用如下方法设置 123.btn + .btn&#123; margin-left: 20px;&#125; 6.强制换行 word-break: break-all 所有字符只要超出就换行，而word-break: break-word会保留整个单词的完整性 7.实现中文两端对齐兼容方案 1234.justify&#123; text-align: justify; text-justify: inter-ideograph;&#125; 8.字符串大小写text-transform 身份证输入等强制大写 123input&#123; text-transform: uppercase;&#125; 9.::first-letter–作用于子元素 应用：实现字体控制 .t-tr{ font-size: 28px; text-indent: 2em; } .t-tr:first-letter{ font-size: 36px; color: red; } ￥200 12345.t-tr:first-letter&#123; font-size: 36px;&#125;&lt;/style&gt;&lt;div class="t-tr"&gt;￥200&lt;/div&gt; 10.隐藏元素的background-image的加载 在firfox下，display:none的元素的background-image不加载，包括父元素设置display: none,在chrome和safari下若父元素为display:none则不加载，本身隐藏会加载，对于ie来说都会加载通过背景图片实现鼠标经过切换图片效果时最好把两张图片合成一张图，这样既减少请求又可以提高用户体验 11.background-position百分比计算规则 positionX = (容器宽度 - 图片宽度) percentXpositionY = (容器高度 - 图片高度) percentY 12.兼容PC端的hidden属性 1234[hidden]&#123; display: none;&#125;&lt;div hidden&gt;&lt;/div&gt; 13.visibility的继承性 父元素设置visibility: hidden,子元素会继承该特性，如果子元素设置visibility: visible,则子元素会显示出来visibility: hidden不会影响计数器技术，而display：none会影响有过渡效果，display则没有 14.user-select:none使得文本不能选中 123user-select: none;/* 默认鼠标图形 */cursor: default; 15.自定义光标 123.cur&#123; cursor: url(transparent.cur);&#125;]]></content>
      <categories>
        <category>css2高级</category>
      </categories>
      <tags>
        <tag>css2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过渡与动画]]></title>
    <url>%2F2018%2F03%2F15%2Fanimation-transition%2F</url>
    <content type="text"><![CDATA[网页中过渡与动画是一种流行的表现手法，可以让界面显得更加生动和真实，接下来我们介绍的css3新特性，可以让你的web变得更加富有动感，让我们来看看精彩的案例吧！ 程序员必读 Css3编码技巧 1.弹性过渡–纯css实现表单提示层效果 知识点：贝塞尔曲线在线工具 .control{ width: 400px; margin: 20px auto; } .tip{ position: absolute; margin-left: -200px; margin-top: 36px; padding: 2px 6px; font-size: 12px; color: #fff; border-radius: 4px; border: 1px solid #ccc; background: #06c; transform-origin: 0 0; transition: transform .5s cubic-bezier(.25,.1,.3,1.5); } input{ width: 200px; height: 26px; } input:not(:focus) + .tip{ transform: scale(0); transition: transform ease .25s; } 用户名 请输入用户名 123456789101112131415161718192021.tip&#123; position: absolute; margin-left: -200px; margin-top: 36px; padding: 2px 6px; font-size: 12px; color: #fff; border-radius: 4px; border: 1px solid #ccc; background: #06c; transform-origin: 0 0; /* 关键 */ transition: transform .5s cubic-bezier(.25,.1,.3,1.5); /* 关键 */&#125;input&#123; width: 200px; height: 26px;&#125;input:not(:focus) + .tip&#123; transform: scale(0); /* 关键 */ transition: transform ease .25s; /* 关键 */&#125; 2.逐帧动画 知识点：steps() .keyframes-wrap{ width: 128px; height: 130px; margin: 20px auto; background: url(http://p3g4ahmhh.bkt.clouddn.com/animate.jpg) no-repeat top left; animation: loader 1s infinite steps(8); text-indent: 200%; white-space: nowrap; overflow: hidden; } @keyframes loader { to { background-position: -1024px; } } 正在加载... 12345678910.keyframes-wrap&#123; background: url(http://p3g4ahmhh.bkt.clouddn.com/animate.jpg) no-repeat top left; animation: loader 1s infinite steps(8); text-indent: 200%; white-space: nowrap; overflow: hidden;&#125;@keyframes loader &#123; to &#123; background-position: -1024px; &#125;&#125; 3.利用css控制动画的暂停和播放 知识点：animation-play-state .bg-wrap{ width: 300px; height: 130px; margin: 20px auto; background: url(http://p3g4ahmhh.bkt.clouddn.com/bg.jpg); background-size: auto 100%; animation: move 5s linear infinite alternate; animation-play-state: paused; } .bg-wrap:hover,.bg-wrap:focus{ animation-play-state: running; } @keyframes move { to { background-position: 100% 0; } } 123456789101112.bg-wrap&#123; background: url(http://p3g4ahmhh.bkt.clouddn.com/bg.jpg); background-size: auto 100%; animation: move 5s linear infinite alternate; animation-play-state: paused;&#125;.bg-wrap:hover,.bg-wrap:focus&#123; animation-play-state: running;&#125;@keyframes move &#123; to &#123; background-position: 100% 0; &#125;&#125; 4.沿环形路径平移的动画 知识点：transform: rotate(1turn); transform-origin变换的源点是基于自身的尺寸,默认值为自身的中心 .box{ display: flex; align-items: center; justify-content: center; width: 200px; height: 200px; border-radius: 100%; overflow: hidden; margin: 20px auto; background: orange; } .avator{ width: 60px; height: 60px; padding: 0; margin: 0 !important; border-radius: 100%; animation: spin 5s linear infinite; } @keyframes spin { from{ transform: rotate(0turn) translateY(-100px) translateY(50%) rotate(1turn) } to{ transform: rotate(1turn) translateY(-100px) translateY(50%) rotate(0turn) } } 1234567891011121314151617/* 首先要想方法让头像在父元素中居中 */.avator&#123; animation: spin 5s linear infinite;&#125;@keyframes spin &#123; from&#123; transform: rotate(0turn) translateY(-100px) translateY(50%) rotate(1turn) &#125; to&#123; transform: rotate(1turn) translateY(-100px) translateY(50%) rotate(0turn) &#125;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>transition</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据兄弟元素数量来设置样式]]></title>
    <url>%2F2018%2F03%2F14%2Fselector%2F</url>
    <content type="text"><![CDATA[接下来我为大家介绍一种类似js效果的选择器，可以根据兄弟元素的数量来设置样式，那么我们开始吧。 程序员必读 Css3编码技巧 1. 当只有一项时的样式–only-child .list{ width: 80%; padding: 1em; margin-left: auto; margin-right: auto; margin-bottom: 20px; border-radius: 8px; color: #fff; background: #000; } .item{ display: inline-block; padding: .4em .6em; border-radius: 8px; line-height: 1em; } .item:only-child{ background: gray; } one 123.item:only-child&#123; /* 只有一个列表项时的样式 */ background: gray;&#125; 2. 根据兄弟元素的数量范围来选择元素 .item:nth-child(n+4){ background: orange; } .item-1:first-child:nth-last-child(n+4), .item-1:first-child:nth-last-child(n+4) ~ .item-1{ background: blue; } .item-2:first-child:nth-last-child(-n+4), .item-2:first-child:nth-last-child(-n+4) ~ .item-2{ background: green; } .item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6), .item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ .item-3{ background: #f6c; } 1. 选择列表中第四项及以后的所有项 one two three four five six 2. 列表至少有4项时选中所有项 one two three four five 3. 列表最多包含4项时选中所有项 one two three four 4. 列表项在2-6项时选中所有项 one two three four five six 1234567891011121314/* 1. 选择列表中第四项及以后的所有项 */.item:nth-child(n+4)/* 2. 列表至少有4项时选中所有项 */.item-1:first-child:nth-last-child(n+4),.item-1:first-child:nth-last-child(n+4) ~ .item-1/* 3. 列表最多包含4项时选中所有项 */.item-2:first-child:nth-last-child(-n+4),.item-2:first-child:nth-last-child(-n+4) ~ .item-2/* 4. 列表项在2-6项时选中所有项 */.item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6),.item-3:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ .item-3]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>nth-child(n)</tag>
        <tag>only-child</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义单选框复选框]]></title>
    <url>%2F2018%2F03%2F14%2Fcheckbox%2F</url>
    <content type="text"><![CDATA[我们都知道原生的复选框控件样式极难自定义，这对于工程师实现设计稿的难度加大了一大截。css3的出现，增加了:checked选择器，因此我们可以利用:checked和label来实现各式各样的表单选择控件，接下来让我们来看看如何实现吧！ 程序员必读 Css3编码技巧 1.自定义复选框 .check-wrap{ text-align: center; } .checkbox{ position: absolute; clip: rect(0,0,0,0); } .checkbox[type="checkbox"]:focus + label::before{ box-shadow: 0 0 .6em #06c; } .checkbox[type="checkbox"] + label::before{ content: '\a0'; /* 不换行空格 */ display: inline-block; margin-right: .3em; width: 2em; height: 2em; border-radius: .3em; vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; background: gray; } .checkbox[type="checkbox"]:checked + label::before{ content: '\2713'; /* 对勾 */ background: black; } label{ margin-right: 40px; font-size: 20px; } 生男孩 生女孩 123456789101112131415161718192021222324.checkbox&#123; position: absolute; clip: rect(0,0,0,0);&#125;.checkbox[type="checkbox"] + label::before&#123; content: '\a0'; /* 不换行空格 */ display: inline-block; margin-right: .3em; width: 2em; height: 2em; border-radius: .3em; vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; background: gray;&#125;.checkbox[type="checkbox"]:checked + label::before&#123; content: '\2713'; /* 对勾 */ background: black;&#125; 2.自定义开关 .check-wrap{ margin-bottom: 20px; text-align: center; } .switch{ position: absolute; clip: rect(0,0,0,0); } .switch[type="checkbox"] + label{ width: 6em; height: 3em; padding: .3em; border-radius: .3em; border: 1px solid rgba(0,0,0,.2); vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; box-shadow: 0 1px white inset; background-color: #ccc; background-image: linear-gradient(#ddd,#bbb); } .switch[type="checkbox"]:checked + label{ box-shadow: 0.05em .1em .2em rgba(0,0,0,.6) inset; border-color: rgba(0,0,0,.3); background: #bbb; } label{ margin-right: 40px; font-size: 14px; } .switch-an{ position: absolute; clip: rect(0,0,0,0); } .switch-an[type="checkbox"] + label{ position: relative; display: inline-block; width: 5em; height: 2em; border-radius: 1em; color: #fff; background: #06c; text-align: left; } .switch-an[type="checkbox"] + label::before{ content: ''; width:2em; height: 2em; position: absolute; left: 0; border-radius: 100%; vertical-align: middle; background-color: #fff; transition: left .3s; } .switch-an[type="checkbox"] + label::after{ content: 'OFF'; margin-left: 2.6em; } .switch-an[type="checkbox"]:checked + label::before{ transition: left .3s; left: 3em; } .switch-an[type="checkbox"]:checked + label::after{ content: 'NO'; margin-left: .6em; } 生男孩 生女孩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* 1 */.switch&#123; position: absolute; clip: rect(0,0,0,0);&#125;.switch[type="checkbox"] + label&#123; width: 6em; height: 3em; padding: .3em; border-radius: .3em; border: 1px solid rgba(0,0,0,.2); vertical-align: middle; line-height: 2em; /* 关键 */ font-size: 20px; text-align: center; color: #fff; box-shadow: 0 1px white inset; background-color: #ccc; background-image: linear-gradient(#ddd,#bbb);&#125;.switch[type="checkbox"]:checked + label&#123; box-shadow: 0.05em .1em .2em rgba(0,0,0,.6) inset; border-color: rgba(0,0,0,.3); background: #bbb;&#125;/* 2 */.switch-an&#123; position: absolute; clip: rect(0,0,0,0);&#125;.switch-an[type="checkbox"] + label&#123; position: relative; display: inline-block; width: 5em; height: 2em; border-radius: 1em; color: #fff; background: #06c; text-align: left;&#125;.switch-an[type="checkbox"] + label::before&#123; content: ''; width:2em; height: 2em; position: absolute; left: 0; border-radius: 100%; vertical-align: middle; background-color: #fff; transition: left .3s;&#125;.switch-an[type="checkbox"] + label::after&#123; content: 'OFF'; margin-left: 2.6em;&#125;.switch-an[type="checkbox"]:checked + label::before&#123; transition: left .3s; left: 3em;&#125;.switch-an[type="checkbox"]:checked + label::after&#123; content: 'NO'; margin-left: .6em;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>checkbox</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-effect]]></title>
    <url>%2F2018%2F03%2F13%2Ftext-effect%2F</url>
    <content type="text"><![CDATA[文字特效在过去大部分都用图片代替，但是自从有了css3,前端的宝宝再也不用担心没有设计师来切图了。接下来就让我来给大家展示text-shadow的强大效果吧！ 程序员必读 Css3编码技巧 1.凸凹印刷效果 .effect-1{ width: 300px; margin-left: auto; margin-right: auto; line-height: 2em; background: hsl(210,13%,60%); color: hsl(210,13%,30%); text-shadow: 0 1px 1px hsla(0,0%,100%,.8); } the only way to get rid of a temptation is to yield to it. 1text-shadow: 0 1px 1px hsla(0,0%,100%,.8); 2.空心字效果 .effect-2{ width: 300px; margin-left: auto; margin-right: auto; font-size: 30px; text-align: center; line-height: 2em; background: deeppink; color: #fff; text-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000; } the only way. 1234text-shadow: 1px 1px #000, -1px -1px #000, 1px -1px #000, -1px 1px #000; 3.文字外发光效果(鼠标经过文字会有惊喜哦！) .effect-3{ width: 300px; margin-left: auto; margin-right: auto; font-size: 30px; text-align: center; line-height: 2em; background: #203; color: #ffc; text-shadow: 0 0 .1em, 0 0 .3em; transition: 1s; } .effect-3:hover{ text-shadow: 0 0 .6em, 0 0 .8em; } hover me! 12text-shadow: 0 0 .1em, 0 0 .3em; 3.文字凸起效果 .effect-4{ width: 300px; margin-left: auto; margin-right: auto; font-size: 30px; text-align: center; line-height: 2em; background: #ccc; color: #fff; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px #000; transition: 1s; } .effect-4:hover{ text-shadow: 0 1px hsl(0,0%,85%); } hover me! 123456text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px 10px #000;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>text-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用码云]]></title>
    <url>%2F2018%2F03%2F12%2Fgit-china%2F</url>
    <content type="text"><![CDATA[使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况。如果我们希望良好的体验速度，可以使用国内的Git托管服务——码云。 使用方法与步骤1.在码云上添加ssh公钥，新建一个项目2.本地库上使用命令git remote add把它和码云的远程库关联。1git remote add origin git@gitee.com:xujiang/learngit.git 之后，就可以正常地用git push和git pull推送了！ 3.如果在使用远程库时报错：1fatal: remote origin already exists. 这说明本地库已经关联了一个远程库，此时，可以先用git remote -v查看远程库信息 我们可以删除已有的GitHub远程库： 1git remote rm origin(假设远程库名叫origin) 再关联码云的远程库： 1git remote add origin git@gitee.com:xujiang/learngit.git 如果我想关联两个不同的版本库呢？ 1.首先远程库A 1git remote add A git@gitee.com:xujiang/learngit.git 2.再关联远程库B 1git remote add B git@github.com:xujiang/learngit.git 此时，如果要推送到A上，则可以： 1git push A master 要推送到B上，则可以： 1git push B master]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git全解读]]></title>
    <url>%2F2018%2F02%2F12%2FgitStudy%2F</url>
    <content type="text"><![CDATA[版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 程序员必读 Css3编码技巧 创建并提交一个版本库 课外知识: mkdir 创建目录; pwd 显示绝对路径; cat 文件名 查看文件内容注：所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，如果要真要使用版本控制系统，就要以纯文本方式编写文件。千万不要使用Windows自带的记事本编辑任何文本文件,原因是Microsoft开发记事本的团队,在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题. 1.核心操作1234567891011# 1.初始化仓库,.git目录默认隐藏,可以通过命令ls -ah显示git init# 2.把文件添加到版本库，可以一次添加多个文件，git add . 代表把所有文件全部提交git add 文件名 文件名# 3.把文件提交到当前分支git commit -m '本次提交的说明'# 4.把项目提交到(远程)仓储git push 2.分支管理123456789101112131415161718192021# 1.查看远程分支git branch -a# 2.查看本地分支git branch# 3.创建并切换分支 （加-b表示创建并切换）git checkout -b 分支名# 4.切换回分支git checkout 分支名# 5.从主分支里创建新分支git checkout master -b 新分支名# 6.合并某分支到当前分支git merge 分支名# 7.删除分支git branch -d 分支名git branch -D 分支名 (强行删除分支) 3.解决冲突123456789101112131415# 情景一 提交或拉取时冲突git stashgit pullgit stash pop# 情景二 如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pullgit reset --hard HEAD^git pull origin master# 注：origin master表示git的主分支# 情景三 分支合并时冲突(当我们git merge 分支名 时)1.git status (查看发生冲突的文)2.然后手动合并冲突3.git add . (添加更改后的文件)4.git commit -m 'xj' (提交) 4.查看ssh密钥1234# 1.进入.ssh目录cd ~/.ssh# 2.查看id_rsa.pub文件cat id_rsa.pub 5.克隆远程项目1git clone 远程源地址 6.回退某个操作1234# 1.查看命令历史git reflog# 2.根据commitID撤销某个操作git reset --hard 某个commitId 7.和远程分支建立关联1git branch --set-upstream-to=origin/远程分支的名字 本地分支名 8.删除文件12345# 删除版本库中的文件git rm filename# 恢复工作区中误删的文件git checkout -- filename# 注：git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 9.远程仓储1234567# 1.创建sshkey密钥ssh-keygen -t rsa -C "youremail@example.com"# 2.在远程仓库中添加ssh公钥# 3.关联远程库git remote add origin git@server-name:path/repo-name.git# 4.第一次推送master分支的所有内容,此后只需要使用git push origin master即可推送最新修改git push -u origin master 10.多人协作12345678910# 1.查看远程仓储的详细信息git remote -v# 2.推送本地分支到远程仓库, #1.如果发生冲突，用git pull试图合并，如果发生冲突则解决冲突，再进行推送 #2.如果git pull后提示no tracking information(没有追踪信息)，则进行第四项，建立关联，之后pull，有冲突再合并git push origin 本地分支名# 3.在本地创建和远程分支对应的分支git checkout -b 本地分支 origin/远程分支名# 4.建立本地分支和远程分支的关联git branch --set-upstream 本地分支名 origin/远程分支名 11.分支策略1231.master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；2.干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；3.每个人都有自己的分支，时不时地往dev分支上合并就可以了 补充 123456789101112131415161718192021# 查看仓库当前的状态git status// 查看提交日志git log# 回退版本,在git中用HEAD表示当前版本,HEAD^表示上一个版本,HEAD^^表示上上个版本git reset --hard HEAD^ 或git reset --hard 3628164 (数字代表log里commit后面的id,只需要填前几位就可以)# 窗口关闭后回退版本(git reflog用来记录你的每一次命令)git reflog# 工作区和暂存区工作区就是你建立的能看见的目录,.git即为git的版本库,Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。用git add把文件添加进去，实际上就是把文件修改添加到暂存区；用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支# 撤销修改1.直接丢弃工作区的修改，用命令git checkout -- file2.修改添加到了暂存区，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3形状篇]]></title>
    <url>%2F2018%2F02%2F10%2Fshape%2F</url>
    <content type="text"><![CDATA[形状是网页中必不可少的一部分,它使得网页更加生动和精致,接下来就让我们开启css3形状之旅！ 程序员必读 Css3：box-shadow高级应用 .black-theme{ margin-left: auto; margin-right: auto; margin-bottom: 20px; text-align: center; border-radius: 8px; background-color: #000; color: #fff; } 1.制做平行四边形/棱形/梯形 知识点: transform: skew(deg),&nbsp;&nbsp;//skew代表斜切,值为角度 transform-origin: bottom/left/top(默认)/right 变换源点的位置 .sp-1{ position: relative; width: 140px; height: 80px; line-height: 80px; color: #fff; text-align: center; background-color: transparent; } .sp-1::before{ content: ''; position: absolute; z-index: -1; left: 0; right: 0; bottom: 0; top: 0; background-color: #06c; transform: skew(45deg); } .sp-1-1::before{ transform: scaleY(2) perspective(.5em) rotateX(5deg); transform-origin: bottom; } 平行四边形 梯形 核心代码 123456789101112131415/* 对伪类添加变形 */.sp-1::before&#123; content: ''; position: absolute; z-index: -1; left: 0; right: 0; bottom: 0; top: 0; background-color: #06c; transform: skew(45deg);&#125;/* 梯形 */transform: scaleY(2) perspective(.5em) rotateX(5deg);transform-origin: bottom; 2.制做切角效果 知识点: 利用背景渐变 .sp-2, .sp-3{ width: 140px; height: 80px; line-height: 80px; color: #fff; text-align: center; border-radius: 0; } .sp-2{ background: linear-gradient(-135deg,transparent 12px,#06c 0); } .sp-3{ background: radial-gradient(circle at top left,transparent 12px,#06c 0) no-repeat 0 0; } 切角 圆形切角 核心代码 1234/* 正切角 */background: linear-gradient(-135deg,transparent 12px,#06c 0);/* 圆形切角 */background: radial-gradient(circle at top left,transparent 12px,#06c 0) no-repeat 0 0;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>border-radius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border——radius篇]]></title>
    <url>%2F2018%2F02%2F10%2Fborder%2F</url>
    <content type="text"><![CDATA[border-radius的出现让我们实现圆角效果提供了极大的便利，我们还可以通过对Border-radius特性的进一步研究来实现各种图形效果，接下来就让我们看看它的威力吧！ 程序员必读 Css3：box-shadow高级应用 .black-theme{ margin-left: auto; margin-right: auto; margin-bottom: 20px; text-align: center; border-radius: 8px; background-color: #000; color: #fff; } 1.制作自适应的椭圆 知识点:border-radius: a / b;&nbsp;&nbsp;&nbsp;&nbsp;//a,b分别为圆角的水平、垂直半径,单位若为%,则表示相对于宽度和高度进行解析 .br-1{ width: 200px; height: 100px; border-radius: 50% /10%; background: linear-gradient(45deg,#06f,#f6c,#06c); } .br-2{ width: 100px; border-radius: 20% 50%; } .ani{ animation: skew 4s infinite; } .ani1{ animation: skew1 4s infinite 2s; } .ani2{ animation: skew2 4s infinite 3s; } @keyframes skew{ to{ border-radius: 50%; } } @keyframes skew1{ to{ border-radius: 20px 20px 100%; } } @keyframes skew2{ to{ transform: rotate(360deg); } } 核心代码 123border-radius: 50% /10%;border-radius: 20px 20px 100%;border-radius: 20% 50%; 3.纯css3实现饼图进度动画 知识点：border-radius: a b c d / e f g h; animation多动画属性; .br-31{ width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(to right,#f6c 50%,#333 0); } .br-31::before{ content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: #f6c; transform-origin: left; animation: skin 4s linear infinite, bg 8s step-end infinite; } @keyframes skin{ to{ transform: rotate(.5turn); } } @keyframes bg{ 50%{ background: #333; } } .br-32::before{ animation-play-state: paused; animation-delay: inherit; } 核心代码 123456789101112131415161718192021222324252627.br-31&#123; width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(to right,#f6c 50%,#333 0);&#125;.br-31::before&#123; content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: #f6c; transform-origin: left; animation: skin 4s linear infinite, bg 8s step-end infinite;&#125;@keyframes skin&#123; to&#123; transform: rotate(.5turn); &#125;&#125;@keyframes bg&#123; 50%&#123; background: #333; &#125;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>border-radius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[box-shadow和filter篇]]></title>
    <url>%2F2018%2F02%2F03%2Fbox-shadow%2F</url>
    <content type="text"><![CDATA[利用css3的新特性可以帮助我们实现各种意想不到的特效,下面就来一起看看吧~ 程序员必读 Css3编码技巧 1.实现水波动画 知识点：box-shadow .wave { margin-left: auto; margin-right: auto; width: 100px; height: 100px; border-radius: 100px; border: 2px solid #fff; text-align: center; line-height: 100px; color: #fff; background: #06c url(http://p3g4ahmhh.bkt.clouddn.com/me.jpg) no-repeat center center; background-size: 100%; animation: wave 4s linear infinite; } @keyframes wave { 0% { box-shadow: 0 0 0 0 rgba(245, 226, 226, 1), 0 0 0 0 rgba(250, 189, 189, 1); } 50% { box-shadow: 0 0 0 20px rgba(245, 226, 226, .5), 0 0 0 0 rgba(250, 189, 189, 1); } 100% { box-shadow: 0 0 0 40px rgba(245, 226, 226, 0), 0 0 0 20px rgba(245, 226, 226, 0); } } 核心代码123456789101112// css@keyframes wave &#123; 0% &#123; box-shadow: 0 0 0 0 rgba(245, 226, 226, 1), 0 0 0 0 rgba(250, 189, 189, 1); &#125; 50% &#123; box-shadow: 0 0 0 20px rgba(245, 226, 226, .5), 0 0 0 0 rgba(250, 189, 189, 1); &#125; 100% &#123; box-shadow: 0 0 0 40px rgba(245, 226, 226, 0), 0 0 0 20px rgba(245, 226, 226, 0); &#125;&#125; 2.实现加载动画 知识点：box-shadow多阴影 .loading { margin-left: auto; margin-right: auto; width: 30px; height: 30px; border-radius: 30px; background-color: transparent; animation: load 3s linear infinite; } @keyframes load { 0% { box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); } 30% { box-shadow: -40px 0 0 rgba(250, 189, 189, 1), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); } 60% { box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 1), 40px 0 0 rgba(250, 189, 189, 0); } 100% { box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 1); } } 核心代码1234567891011121314151617181920212223// css@keyframes load &#123; 0% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); &#125; 30% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 1), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 0); &#125; 60% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 1), 40px 0 0 rgba(250, 189, 189, 0); &#125; 100% &#123; box-shadow: -40px 0 0 rgba(250, 189, 189, 0), inset 0 0 0 15px rgba(250, 189, 189, 0), 40px 0 0 rgba(250, 189, 189, 1); &#125;&#125; 3.投影 知识点：box-shadow 1.单侧投影 .single-shadow{ margin-left: auto; margin-right: auto; width: 200px; height: 80px; background: #06c; box-shadow: 0 8px 4px -4px #666; } 核心代码1box-shadow: 0 8px 4px -4px #666; 2.双侧投影 .double-shadow{ margin-left: auto; margin-right: auto; width: 200px; height: 80px; background: #06c; box-shadow: 8px 0 10px -8px #000, -8px 0 10px -8px #000; } 核心代码12box-shadow: 8px 0 10px -8px #000, -8px 0 10px -8px #000; 3.不规则投影 .odd-shadow{ margin-left: auto; margin-right: auto; width: 200px; height: 80px; border-radius: 8px; color: #fff; font-size: 24px; text-align: center; line-height: 80px; background: #06c; filter: drop-shadow(2px 2px 2px rgba(0,0,0,.8)) } .odd-shadow::before{ content: ''; position: absolute; display: block; margin-left: -20px; transform: translateY(20px); width:0; height: 0; border: 10px solid transparent; border-right-color: #06c; } 哎呦，猪先森 核心代码12/* 注：padding/margin设置百分比单位时，是基于父元素宽度的 */filter: drop-shadow(2px 2px 2px rgba(0,0,0,.8)) 4.滤镜filter1.染色效果 .img-filter{ margin-left: auto; margin-right: auto; width: 200px; display: block; border-radius: 100%; } .img-filter-1{ filter: sepia(1) } .img-filter-2{ filter: saturate(4) } .img-filter-3{ filter: hue-rotate(295deg) } .img-filter-4{ filter: sepia(1) saturate(4) hue-rotate(295deg) } 原图 染色后--sepia()会给图片增加一种降饱和度的橙黄色染色效果 染色后--saturate()会给图片的每个像素提高饱和度 染色后--hue-rotate()会给每个像素的色相进以指定度数进行偏移 染色后--多个滤镜组合 核心代码 12345678/* sepia() */filter: sepia(1)/* saturate() */filter: saturate(4)/* hue-rotate() */filter: hue-rotate(295deg)/* 混合 */filter: sepia(1) saturate(2) hue-rotate(100deg) 2.模糊效果 .img-blur{ margin-left: auto; margin-right: auto; width: 80px; height: 80px; border-radius: 8px; text-align: center; background-color: rgba(100,100,255,1); filter: blur(20px); color: #000; } Mr XuJiang, Love you. 核心代码 1filter: blur(20px);]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>box-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border和background篇]]></title>
    <url>%2F2018%2F01%2F30%2Fanimation%2F</url>
    <content type="text"><![CDATA[自从有了Css3 transition和animation以来,前端开发在动画这一块有了更高的自由度和格局,对动画的开发也越来越容易.这篇文章就让我们汇总一下使用Css3实现的各种特效. 程序员必读 Css3编码技巧 .black-theme{ margin-left: auto; margin-right: auto; margin-bottom: 20px; text-align: center; border-radius: 8px; background-color: #000; color: #fff; } 1.实现内部虚线边框 知识点：outline .dash-border{ width: 200px; height: 100px; line-height: 100px; outline: 1px dashed #fff; outline-offset: -10px; } hello world 核心代码12345// css.dash-border&#123; outline: 1px dashed #fff; outline-offset: -10px;&#125; 2.边框内圆角的实现 知识点：box-shadow .radius-border{ margin-top: 20px; width: 180px; height: 80px; box-shadow: 0 0 0 10px gray; } 核心代码 1box-shadow: 0 0 0 10px gray; 3.实现条纹背景与进度条 知识点：linear-gradient,repeating-linear-gradient .bg-stripe{ margin-top: 20px; width: 180px; height: 20px; background: linear-gradient(to right,#fb3 50%,#58a 0); background-size: 40px 100%; box-shadow: inset 0 0 3px #555; } .bg-stripe-2{ background: linear-gradient(45deg,#fb3 25%,#58a 0,#58a 50%,#fb3 0,#fb3 75%,#58a 0); background-size: 40px 40px; } .bg-stripe-3{ background: repeating-linear-gradient(60deg,#fb3,#fb3 15px,#58a 0,#58a 30px); } 核心代码 12345678910// 上background: linear-gradient(to right,#fb3 50%,#58a 0);background-size: 40px 100%;// 中background: linear-gradient(45deg,#fb3 25%,#58a 0,#58a 50%,#fb3 0,#fb3 75%,#58a 0);background-size: 40px 40px;// 下 (可以实现任意角度的渐变，45°时显示效果最好)background: repeating-linear-gradient(60deg,#fb3,#fb3 15px,#58a 0,#58a 30px); 4.复杂的背景图案 知识点：linear-gradient,repeating-linear-gradient,radial-gradient .bg-grid{ margin-top: 20px; width: 200px; height: 200px; background-image: linear-gradient(rgba(255,255,255,1) 2px,transparent 0), linear-gradient(to right,rgba(255,255,255,1) 2px,transparent 0), linear-gradient(rgba(255,255,255,.2) 1px,transparent 0), linear-gradient(to right,rgba(255,255,255,.2) 1px,transparent 0); background-position: -50px -50px; background-size: 100px 100px,100px 100px, 100% 10px, 10px 100%; } .animate-grid{ animation: move-grid 6s linear infinite; } @keyframes move-grid{ 0%{ background-position: -50px -50px; } 30%{ background-position: -100px -100px; } 60%{ background-position: -100px -150px; } 100%{ background-position: -50px -50px; } } 核心代码 1234567// 1background-image: linear-gradient(rgba(255,255,255,1) 2px,transparent 0), linear-gradient(to right,rgba(255,255,255,1) 2px,transparent 0), linear-gradient(rgba(255,255,255,.2) 1px,transparent 0), linear-gradient(to right,rgba(255,255,255,.2) 1px,transparent 0); background-position: -50px -50px; background-size: 100px 100px,100px 100px, 100% 10px, 10px 100%; .bg-dot{ margin-top: 20px; width: 200px; height: 50px; background-image: radial-gradient(circle,#0cf 15px,transparent), radial-gradient(circle,red 15px,transparent), radial-gradient(circle,yellow 15px,transparent), radial-gradient(circle,green 15px,transparent); background-repeat: no-repeat; background-position: 0 0, 50px 0, 100px 0, 150px 0, 200px 0; background-size: 50px 50px; } .animate-dot{ animation: move-dot 8s linear infinite; } .animate-dot2{ animation: move-dot2 6s linear infinite; } @keyframes move-dot{ 0%{ background-position: 0 0, 50px 0, 100px 0, 150px 0; } 30%{ background-position: 50px 0, 0 0, 100px 0, 150px 0; } 60%{ background-position: 50px 0, 100px 0, 0 0, 150px 0; } 100%{ background-position: 50px 0, 100px 0, 150px 0, 0 0; } } @keyframes move-dot2{ 0%{ background-image: radial-gradient(circle,#0cf 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent); } 30%{ background-image: radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,red 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent); } 60%{ background-image: radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,yellow 15px,transparent), radial-gradient(circle,gray 15px,transparent); } 100%{ background-image: radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,gray 15px,transparent), radial-gradient(circle,green 15px,transparent); } } 核心代码 12345678// 利用css3多背景和position实现红绿灯和背景色块移动background-image: radial-gradient(circle,#0cf 15px,transparent), radial-gradient(circle,red 15px,transparent), radial-gradient(circle,yellow 15px,transparent), radial-gradient(circle,green 15px,transparent); background-repeat: no-repeat; background-position: 0 0, 50px 0, 100px 0, 150px 0, 200px 0; background-size: 50px 50px; .bg-qi{ margin-top: 20px; width: 200px; height: 200px; background-color: #eee; background-image: linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0), linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0); background-position: 0 0, 20px 20px; background-size: 40px 40px; box-shadow: 2px 2px 4px rgba(0,0,0,.4); } 核心代码 12345// 利用背景渐变实现棋盘图案background-image: linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0), linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 0,transparent 75%,rgba(0,0,0,.25) 0);background-position: 0 0, 20px 20px;background-size: 40px 40px; 伪随机背景 .bg-line-rand{ margin-top: 20px; width: 480px; height: 60px; background-color: #eee; background-image: linear-gradient(90deg,#fb3 11px, transparent 0), linear-gradient(90deg,#ab4 23px, transparent 0), linear-gradient(90deg,#655 41px, transparent 0); background-size: 41px 100%, 61px 100%, 83px 100%; box-shadow: 2px 2px 4px rgba(0,0,0,.4); } .bg-dot-rand{ margin-top: 20px; width: 200px; height: 200px; background-color: #eee; background-image: radial-gradient(circle,#fb3 5px, transparent 0), radial-gradient(circle,#ab4 13px, transparent 0), radial-gradient(circle,#655 31px, transparent 0); background-repeat: no-repeat; background-size: 101px 203px, 147px 60px, 373px 201px; box-shadow: 2px 2px 4px rgba(0,0,0,.4); } .animate1{ animation: move 4s linear infinite; } .animate2{ animation: move2 4s linear infinite; } @keyframes move{ 0%{ background-position: 0 0, 0 0, 0 0; } 50%{ background-position: -10px 0, 20px 0, 30px 0; } 100%{ background-position: 0 0, 30px 0, 10px 0; } } @keyframes move2{ 0%{ background-position: 0 0, 0 0, 0 0; } 50%{ background-position: -10px 30px, 20px 0, -40px 80px; } 100%{ background-position: 0 20px, 60px -20px, 10px 30px; } } 核心代码 12345678910111213// 利用背景渐变实现棋盘图案/*线性*/background-image: linear-gradient(90deg,#fb3 11px, transparent 0), linear-gradient(90deg,#ab4 23px, transparent 0), linear-gradient(90deg,#655 41px, transparent 0); background-size: 41px 100%, 61px 100%, 83px 100%;/*径向*/background-image: radial-gradient(circle,#fb3 5px, transparent 0), radial-gradient(circle,#ab4 13px, transparent 0), radial-gradient(circle,#655 31px, transparent 0);background-repeat: no-repeat;background-size: 101px 203px, 147px 60px, 373px 201px; 5.折角效果 知识点：linear-gradient 1.折角效果 .fold{ margin-left: auto; margin-right: auto; margin-bottom: 20px; width: 200px; height: 80px; color: #fff; line-height: 80px; text-align: center; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.5) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg,transparent 1.4em,#06c 0); } .linear{ background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.5)) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg,transparent 1.4em,#06c); } 折角效果哦 折角效果哦 核心代码 12background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.5) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg,transparent 1.4em,#06c 0); 2.内阴影圆折角效果 .fold-1{ margin-left: auto; margin-right: auto; margin-bottom: 20px; position: relative; width: 200px; height: 80px; border-radius: .5em; color: #fff; line-height: 80px; text-align: center; background: linear-gradient(-150deg,transparent 1.5em, #58a 0); } .fold-1::before{ content: ""; position: absolute; top: 0; right: 0; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.2) 0,rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; transform: translateY(-1.3em) rotate(-30deg); transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15); } 折角效果哦 核心代码 1234567891011121314151617181920212223242526.fold-1&#123; margin-left: auto; margin-right: auto; margin-bottom: 20px; position: relative; width: 200px; height: 80px; border-radius: .5em; color: #fff; line-height: 80px; text-align: center; background: linear-gradient(-150deg,transparent 1.5em, #58a 0);&#125;.fold-1::before&#123; content: ""; position: absolute; top: 0; right: 0; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.2) 0,rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; transform: translateY(-1.3em) rotate(-30deg); transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15);&#125; 6.自适应文本的条纹背景 知识点：linear-gradient,line-height,background-origin .stripe-bg{ padding: .5em; line-height: 1.5em; background: beige; background-size: auto 3em; background-origin: content-box; background-image: linear-gradient(rgba(0,0,0,.2) 50%, transparent 0); } .stripe-bg > p{ margin: 0; } hello you hello you hello you hello you hello you 7.自定义的下划线实现 知识点linear-gridient .my-line{ line-height: 1.4em; background: linear-gradient(gray,gray) no-repeat; background-size: 100% 1px; background-position: 0 1.15em; text-shadow: .05em 0 #fff, -.05em 0 #fff; } i have your big apple.you have a too? hi hi hi. 小伙伴们注意到了吗？默认的下划线会将文字穿过，而上面的不会呦！ 12345678# 核心代码.my-line&#123; line-height: 1.4em; background: linear-gradient(gray,gray) no-repeat; background-size: 100% 1px; background-position: 0 1.15em; text-shadow: .05em 0 #fff, -.05em 0 #fff;&#125;]]></content>
      <categories>
        <category>Css3高级实用技巧大全</category>
      </categories>
      <tags>
        <tag>Css3</tag>
        <tag>outline</tag>
        <tag>radial-gradient</tag>
        <tag>linear-gradient</tag>
        <tag>box-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客测试]]></title>
    <url>%2F2018%2F01%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎访问猪先森的博客,这篇文章是教你如何快速创建一个基于HEXO的博客,涉及到node和npm的相关使用,如果你是一枚程序猿,如果你还没有一个上手的博客,哈哈,你懂的,赶快来围观吧！ 快速开始创建一个博客文章页面1$ hexo new "My New Post" 更多参考: Writing 运行服务器1$ hexo server 更多参考: Server 生成静态文件1$ hexo generate 更多参考: Generating 发布到远程站点1$ hexo deploy 更多参考: Deployment hexo高级技巧 实现博客页面自定义交互 1&lt;escape&gt;在此标签内的元素可以不被hexo解析&lt;/escape&gt;]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
